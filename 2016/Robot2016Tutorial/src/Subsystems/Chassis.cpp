// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Chassis.h"
#include "../RobotMap.h"
#include "../Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Chassis::Chassis() : Subsystem("Chassis") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motorL2 = RobotMap::chassisMotorL2;
    leftEncoder = RobotMap::chassisLeftEncoder;
    leftPID = RobotMap::chassisLeftPID;
    motorR4 = RobotMap::chassisMotorR4;
    rightEncoder = RobotMap::chassisRightEncoder;
    rightPID = RobotMap::chassisRightPID;
    motorL3 = RobotMap::chassisMotorL3;
    motorR5 = RobotMap::chassisMotorR5;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    printf("2135: Creating New Robot Drive\n");
    robotDrive = new RobotDrive(motorL2, motorR4);
    printf("2135: Finish Creating New Robot Drive\n");

    robotDrive->SetSafetyEnabled(false);

    motorL2->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);
    motorL3->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);
    motorR4->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);
    motorR5->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);

    motorL3->SetControlMode(CANSpeedController::kFollower);
    motorL3->Set(2);
    motorR5->SetControlMode(CANSpeedController::kFollower);
    motorR5->Set(4);

    motorR4->SetClosedLoopOutputDirection(true);

    motorL2->SetFeedbackDevice(CANTalon::FeedbackDevice::QuadEncoder);
    motorL2->SetSensorDirection(true);

    motorR4->SetFeedbackDevice(CANTalon::FeedbackDevice::QuadEncoder);
    motorR4->SetSensorDirection(false);

    motorL2->ConfigEncoderCodesPerRev(M_COUNTS_PER_ROTATION);
    motorR4->ConfigEncoderCodesPerRev(M_COUNTS_PER_ROTATION);

    motorL2->ConfigPeakOutputVoltage( +5, -5);
    motorL2->ConfigNominalOutputVoltage(+0, -0);

    motorR4->ConfigPeakOutputVoltage( +5, -5);
    motorR4->ConfigNominalOutputVoltage(+0, -0);

    m_driveDirection = -1.0;
    m_driveScalingFactor = 0.9;
    m_scaled = true;
    m_driveSpinSetting = 0.4;
    m_rotations = 0.0;
    m_absTolerance = 0.2;
    m_brakeMode = false;
}

void Chassis::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new DriveTeleop());
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Chassis::Initialize(Preferences *prefs)
{
	printf("2135: Chassis Initialize\n");

	//Initialize and read preferences file

	//AutoDriveDistance
	SmartDashboard::PutNumber("AutoDriveDistance", Robot::LoadPreferencesVariable("AutoDriveDistance", 12.0));

	//AutoDriveTimed
	SmartDashboard::PutNumber("AutoDriveTimed", Robot::LoadPreferencesVariable("AutoDriveTimed", 2.25));

	//AutoDriveTimedSpeed
	SmartDashboard::PutNumber("AutoDriveTimedSpeed", Robot::LoadPreferencesVariable("AutoDriveTimedSpeed", 0.9));

	//AutoDriveTimedWait
	SmartDashboard::PutNumber("AutoDriveTimedWait", Robot::LoadPreferencesVariable("AutoDriveTimedWait", 2.0));

	//ChassDriveScaling
	m_driveScalingFactor = Robot::LoadPreferencesVariable("ChassDriveScaling", 0.85);
	SmartDashboard::PutNumber("ChassDriveScaling", m_driveScalingFactor);

	//ChassDriveSpinSetting
	m_driveSpinSetting = Robot::LoadPreferencesVariable("ChassDriveSpinSetting", 0.4);
	SmartDashboard::PutNumber("ChassDriveSpinSetting", m_driveSpinSetting);

	//ChassDriveVoltRampRate
	SmartDashboard::PutNumber("ChassDriveVoltRampRate", Robot::LoadPreferencesVariable("ChassDriveVoltRampRate", 0.0));

	//ChassPIDAbsTolerance
	m_absTolerance = Robot::LoadPreferencesVariable("ChassPIDAbsTolerance", 0.2);
	SmartDashboard::PutNumber("ChassPIDAbsTolerance", m_absTolerance);

	//ChassPIDPeakOutVolts
	SmartDashboard::PutNumber("ChassPIDPeakOutVolts", Robot::LoadPreferencesVariable("ChassPIDPeakOutVolts", 5.0));

	//ChassPIDProportional
	SmartDashboard::PutNumber("ChassPIDProportional", Robot::LoadPreferencesVariable("ChassPIDProportional", 0.3));

	//ChassPIDVoltRampRate
	SmartDashboard::PutNumber("ChassPIDVoltRampRate", Robot::LoadPreferencesVariable("ChassPIDVoltRampRate", 8.0));

	SmartDashboard::PutNumber("Drive Invert", m_driveDirection);
	SmartDashboard::PutNumber("Left Encoder", (motorL2->GetEncPosition() * -1));
	SmartDashboard::PutNumber("Right Encoder", motorR4->GetEncPosition());
	SmartDashboard::PutBoolean("BrakeMode", m_brakeMode);

}


void Chassis::MoveWithJoystick(std::shared_ptr<Joystick> joystick)
{
	double xValue;
	double yValue;

	xValue = joystick->GetX() * -1;
	yValue = joystick->GetY() * m_driveDirection;

	if (m_scaled) {
		xValue = xValue * m_driveScalingFactor;
		yValue = yValue * m_driveScalingFactor;
	}

	robotDrive->ArcadeDrive( yValue, xValue, true );

	UpdateEncoderDisplays();
}


void Chassis::MoveUsingLeftRightMotorOutputs(double left, double right)
{
	robotDrive->SetLeftRightMotorOutputs( left, right );

	UpdateEncoderDisplays();
}


void Chassis::MoveSpin(bool spinLeft)
{
	if (spinLeft)
		robotDrive->SetLeftRightMotorOutputs( -m_driveSpinSetting, m_driveSpinSetting );
	else
		robotDrive->SetLeftRightMotorOutputs( m_driveSpinSetting, -m_driveSpinSetting );

	UpdateEncoderDisplays();
}


void Chassis::MoveStop(void)
{
	robotDrive->SetLeftRightMotorOutputs( 0.0, 0.0 );
}


void Chassis::MoveLowShift(bool scaled)
{
	m_scaled = scaled;
}


void Chassis::ReverseDriveTrain(void)
{
	m_driveDirection = -m_driveDirection;
	SmartDashboard::PutNumber("Drive Invert", m_driveDirection);
}


void Chassis::MoveDistanceWithPIDInit( double distance )
{
	double voltageRampRate;
	double peakOutputVoltage;
	double proportional;
	double rotations;

	voltageRampRate = SmartDashboard::GetNumber("ChassPIDVoltRampRate", 8.0);
	peakOutputVoltage = SmartDashboard::GetNumber("ChassPIDPeakOutVolts", 5.0);
	proportional = SmartDashboard::GetNumber("ChassPIDProportional", 0.3);
	m_absTolerance = SmartDashboard::GetNumber("ChassPIDAbsTolerance", 0.2);

	motorL2->ConfigPeakOutputVoltage(peakOutputVoltage, peakOutputVoltage*(-1));
	motorR4->ConfigPeakOutputVoltage(peakOutputVoltage, peakOutputVoltage*(-1));

	rotations = distance / (M_WHEEL_DIA * M_PI);

	printf("2135: Encoder Distance %f rotations\n", rotations);

	motorL2->SetAllowableClosedLoopErr(m_absTolerance);
	motorR4->SetAllowableClosedLoopErr(m_absTolerance);

	motorL2->SetPID( (double) proportional, 0.0, 0.0 );
	motorR4->SetPID( (double) proportional, 0.0, 0.0 );

	motorL2->SetVoltageRampRate(voltageRampRate);
	motorL2->SetControlMode(CANSpeedController::ControlMode::kPosition);

	motorR4->SetVoltageRampRate(voltageRampRate);
	motorR4->SetControlMode(CANSpeedController::ControlMode::kPosition);

	motorL2->SetEncPosition(0);
	motorR4->SetEncPosition(0);

	motorL2->Set(rotations);
	motorR4->Set(rotations);

	m_rotations = rotations;

	printf("2135: Left and Right PIDs are enabled\n");
}


void Chassis::MoveDistanceWithPIDExecute( void )
{
	// See if we have reached the target rotations within the tolerance and shut off motor
	if (abs(motorL2->GetEncPosition() - m_rotations) <= m_absTolerance) {
		printf("2135: Left PID is Disabled\n");
		motorL2->Set(0.0);
	}

	if (abs(motorR4->GetEncPosition() - m_rotations) <= m_absTolerance) {
		printf("2135: Right PID is Disabled\n");
		motorR4->Set(0.0);
	}

	UpdateEncoderDisplays();
}


bool Chassis::MoveDistanceWithPIDIsAtSetpoint( void)
{
	bool bothOnTarget;

	// are both PIDs on target
	bothOnTarget = false;

	// Both targets must have been reached
	if ((abs(motorL2->GetEncPosition() - m_rotations) <= m_absTolerance) &&
			(abs(motorR4->GetEncPosition() - m_rotations) <= m_absTolerance)) {
		MoveDistanceWithPIDStop();
		bothOnTarget = true;
	}

	return bothOnTarget;
}


void Chassis::MoveDistanceWithPIDStop( void )
{
	motorL2->SetControlMode(CANSpeedController::ControlMode::kPercentVbus);
	motorR4->SetControlMode(CANSpeedController::ControlMode::kPercentVbus);
	robotDrive->SetSafetyEnabled(true);
}


void Chassis::SetVoltRampRate(double voltageRampRate)
{
	motorL2->SetVoltageRampRate(voltageRampRate);
	motorR4->SetVoltageRampRate(voltageRampRate);
}

void Chassis::ToggleBrakeMode( void )
{
	if (m_brakeMode == true) {
		motorL2->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);
		motorL3->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);
		motorR4->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);
		motorR5->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Coast);
	}
	else {
		motorL2->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Brake);
		motorL3->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Brake);
		motorR4->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Brake);
		motorR5->ConfigNeutralMode(CANSpeedController::NeutralMode::kNeutralMode_Brake);
	}
	m_brakeMode = !m_brakeMode;
	SmartDashboard::PutBoolean("BrakeMode", m_brakeMode);
}
void Chassis::UpdateEncoderDisplays( void )
{
	static int updateCounter;			// Counter for updating encoder values

	// Update SmartDashboard values - Each counter tick is 20msec
	if (updateCounter % 5 == 0)
	{
		SmartDashboard::PutNumber("Left Encoder", (motorL2->GetEncPosition() * -1));
		SmartDashboard::PutNumber("Right Encoder", motorR4->GetEncPosition());
	}

	// Print to display
	if (updateCounter % 50 == 0)
	{
//		printf("2135: Left Encoder  %d\n", (motorL2->GetEncPosition() * -1));
//		printf("2135: Right Encoder %d\n", motorR4->GetEncPosition());
	}

	updateCounter++;
}
