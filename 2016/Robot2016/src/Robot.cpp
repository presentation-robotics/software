// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "Commands/DriveStop.h"
#include "Commands/AutoDriveTimed.h"
#include "Commands/AutoLowBar.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Chassis> Robot::chassis;
std::shared_ptr<Sweeper> Robot::sweeper;
std::shared_ptr<Shooter> Robot::shooter;
std::shared_ptr<Light> Robot::light;
std::shared_ptr<Climber> Robot::climber;
std::shared_ptr<Pneumatics> Robot::pneumatics;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    chassis.reset(new Chassis());
    sweeper.reset(new Sweeper());
    shooter.reset(new Shooter());
    light.reset(new Light());
    climber.reset(new Climber());
    pneumatics.reset(new Pneumatics());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	autonomousCommand.reset(new DriveStop());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	// Build and display autoChooser
	chooser = new SendableChooser();
	chooser->AddObject("Auto low bar", (void*) AUTOLOWBAR);
	chooser->AddObject("Auto drive timed", (void*) AUTODRIVETIMED);
	chooser->AddDefault("Sit still", (void*) SITSTILL);
	SmartDashboard::PutData("Auto Mode Chooser", chooser);

	printf("2135: Building autonomous chooser complete\n");
	fflush(stdout);

	// Start up the camera
//	CameraServer::GetInstance()->StartAutomaticCapture("cam1");
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit() {
	printf("2135: DisabledInit Running\n");
	light->Initialize(prefs);
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
	// While disabled, if the roborio user button is pressed, dump faults
	if (GetUserButton())
		HandleFaults();
}

void Robot::AutonomousInit() {
	// Initialize preferences file on roboRio
	prefs = Preferences::GetInstance();

	//Initialize SmartDashboard and Subsystems
	chassis->Initialize(prefs);
	fflush(stdout);
	sweeper->Initialize(prefs);
	fflush(stdout);
	shooter->Initialize(prefs);
	fflush(stdout);
	climber->Initialize(prefs);
	fflush(stdout);
	pneumatics->Initialize(prefs);
	fflush(stdout);

	printf("2135: Starting Autonomous Command\n");
	switch ((int)(chooser->GetSelected())) {
		default:
		case SITSTILL:
			autonomousCommand.reset(new DriveStop());
			break;
		case AUTODRIVETIMED:
			double driveTime;
			double driveSpeed;
			driveTime = SmartDashboard::GetNumber("AutoDriveTimed", 2.25);
			driveSpeed = SmartDashboard::GetNumber("AutoDriveTimedSpeed", 0.9);
			autonomousCommand.reset(new AutoDriveTimed(0.0, driveTime, driveSpeed));
			break;
		case AUTOLOWBAR:
			autonomousCommand.reset(new AutoLowBar());
			break;
	}

	if (autonomousCommand.get() != nullptr) {
		autonomousCommand->Start();
		printf("2135: Autonomous Command Started\n");
	}
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	// Initialize preferences file on roboRio
	prefs = Preferences::GetInstance();

	//Initialize SmartDashboard and Subsystems
	chassis->Initialize(prefs);
	fflush(stdout);
	sweeper->Initialize(prefs);
	fflush(stdout);
	shooter->Initialize(prefs);
	fflush(stdout);
	climber->Initialize(prefs);
	fflush(stdout);
	pneumatics->Initialize(prefs);
	fflush(stdout);

	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();
}

void Robot::TeleopPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TestPeriodic() {
	lw->Run();
}

double Robot::LoadPreferencesVariable(std::string name, double defaultValue) {
	Preferences	*prefs;
	double 		value;

	prefs = Preferences::GetInstance();

	if (prefs->ContainsKey(name)) {
		value = prefs->GetDouble(name, defaultValue);
	}
	else {
		value = defaultValue;
		printf("2135: ERROR - %-20s not found\n", name.c_str());
	}
	printf("2135: PREF %-20s : %6.3f\n", name.c_str(), value);

	return value;
}

void Robot::HandleFaults(void) {
	uint16_t	faults;
	uint16_t	stickyFaults;

	faults = RobotMap::chassisMotorL2->GetFaults();
	stickyFaults = RobotMap::chassisMotorL2->GetStickyFaults();
	RobotMap::chassisMotorL2->ClearStickyFaults();
	PrintFaults("chassisMotorL2", faults, stickyFaults);

	faults = RobotMap::chassisMotorL3->GetFaults();
	stickyFaults = RobotMap::chassisMotorL2->GetStickyFaults();
	RobotMap::chassisMotorL3->ClearStickyFaults();
	PrintFaults("chassisMotorL3", faults, stickyFaults);

	faults = RobotMap::chassisMotorR4->GetFaults();
	stickyFaults = RobotMap::chassisMotorR4->GetStickyFaults();
	RobotMap::chassisMotorR4->ClearStickyFaults();
	PrintFaults("chassisMotorR4", faults, stickyFaults);

	faults = RobotMap::chassisMotorR5->GetFaults();
	stickyFaults = RobotMap::chassisMotorR5->GetStickyFaults();
	RobotMap::chassisMotorR5->ClearStickyFaults();
	PrintFaults("chassisMotorR5", faults, stickyFaults);

	faults = RobotMap::sweeperMotorAcquire->GetFaults();
	stickyFaults = RobotMap::sweeperMotorAcquire->GetStickyFaults();
	RobotMap::sweeperMotorAcquire->ClearStickyFaults();
	PrintFaults("sweeperMotorAcquire(6)", faults, stickyFaults);

	faults = RobotMap::sweeperIndexerAcquire->GetFaults();
	stickyFaults = RobotMap::sweeperIndexerAcquire->GetStickyFaults();
	RobotMap::sweeperIndexerAcquire->ClearStickyFaults();
	PrintFaults("sweeperIndexerAcquire(7)", faults, stickyFaults);

	faults = RobotMap::shooterLowerMotor->GetFaults();
	stickyFaults = RobotMap::shooterLowerMotor->GetStickyFaults();
	RobotMap::shooterLowerMotor->ClearStickyFaults();
	PrintFaults("shooterLowerMotor(8)", faults, stickyFaults);

	faults = RobotMap::shooterUpperMotor->GetFaults();
	stickyFaults = RobotMap::shooterUpperMotor->GetStickyFaults();
	RobotMap::shooterUpperMotor->ClearStickyFaults();
	PrintFaults("shooterUpperMotor(9)", faults, stickyFaults);

	RobotMap::pneumaticsPDP->ClearStickyFaults();
}

void Robot::PrintFaults(const char *talonName, uint16_t faults, uint16_t stickyFaults) {

	printf("2135: %s\n", talonName);

	if (faults & CANSpeedController::kTemperatureFault)
		printf("\tkTemperatureFault\n");
	if (faults & CANSpeedController::kBusVoltageFault)
		printf("\tkBusVoltageFault\n");
	if (faults & CANSpeedController::kFwdLimitSwitch)
		printf("\tkFwdLimitSwitch\n");
	if (faults & CANSpeedController::kRevLimitSwitch)
		printf("\tkRevLimitSwitch\n");
	if (faults & CANSpeedController::kFwdSoftLimit)
		printf("\tkFwdLimitSwitch\n");
	if (faults & CANSpeedController::kRevSoftLimit)
		printf("\tkRevLimitSwitch\n");

	if (stickyFaults & CANSpeedController::kTemperatureFault)
		printf("\tSticky - kTemperatureFault\n");
	if (stickyFaults & CANSpeedController::kBusVoltageFault)
		printf("\tSticky - kBusVoltageFault\n");
	if (stickyFaults & CANSpeedController::kFwdLimitSwitch)
		printf("\tSticky - kFwdLimitSwitch\n");
	if (stickyFaults & CANSpeedController::kRevLimitSwitch)
		printf("\tSticky - kRevLimitSwitch\n");
	if (stickyFaults & CANSpeedController::kFwdSoftLimit)
		printf("\tSticky - kFwdLimitSwitch\n");
	if (stickyFaults & CANSpeedController::kRevSoftLimit)
		printf("\tSticky - kRevLimitSwitch\n");
}

START_ROBOT_CLASS(Robot);

