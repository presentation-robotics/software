// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "DriveStraightDistance.h"
#include "math.h"
DriveStraightDistance::DriveStraightDistance() {
	m_timeout = 3;
	m_targetInches = 24;
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::chassis);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
// Called just before this Command runs the first time
void DriveStraightDistance::Initialize() {
	printf ("2135: DriveStraightDistance:  %5.1f inches\n", m_targetInches);
	SetTimeout(m_timeout);
	m_startLeftInches = RobotMap::chassisLeftEncoder->GetDistance();
	m_startRightInches = RobotMap::chassisRightEncoder->GetDistance();
}
// Called repeatedly when this Command is scheduled to run
void DriveStraightDistance::Execute() {
	double	leftDistance;		// Left side distance traveled
	double	rightDistance;		// Right side distance traveled
	double	leftDirection;		// Direction to apply to left motor
	double	rightDirection;		// Direction to apply to right motor
	double	leftPower;			// Left side motor power
	double	rightPower;			// Right side motor power
	
	//	Get distance from starting point
	leftDistance = RobotMap::chassisLeftEncoder->GetDistance()- m_startLeftInches;
	rightDistance = RobotMap::chassisRightEncoder->GetDistance() - m_startRightInches;
	
	//	Indicate direction of travel
	leftDirection = ( m_targetInches - leftDistance > 0 ) ? +1.0 : -1.0;
	rightDirection = ( m_targetInches - rightDistance > 0 ) ? +1.0 : -1.0;
	
	//	Filter power level to use based on distance to target
	leftPower = abs( m_targetInches - leftDistance > 0 ) ? 0.6 : 0.3;
	rightPower = abs( m_targetInches - rightDistance > 0 ) ? 0.6 : 0.3;
	
	//	Calculate motor power
	leftPower *= leftDirection;
	rightPower *= rightDirection;
	
	//	Send power to the motors
	Robot::chassis->DriveUsingLeftRightMotorOutputs(leftPower, rightPower);
	printf ("2135: Execute      L %6.3f  R %6.3f\n", leftDistance, rightDistance);
}
// Make this return true when this Command no longer needs to run execute()
bool DriveStraightDistance::IsFinished() {
	double	leftDistance;		// Left side distance traveled
	double	rightDistance;		// Right side distance traveled
	bool	atTarget;			// Boolean to indicate target reached
	
	//	Get distance from starting point
	leftDistance = RobotMap::chassisLeftEncoder->GetDistance() - m_startLeftInches;
	rightDistance = RobotMap::chassisRightEncoder->GetDistance() - m_startRightInches;
	
	//	See if target reached
	atTarget = ( fabs( m_targetInches - leftDistance ) < 2.0 )
		&& ( fabs( m_targetInches -  rightDistance ) < 2.0 );
	
	printf ("2135: IsFinishedt  L %6.3f  R %6.3f\n", 
		( m_targetInches - leftDistance ), ( m_targetInches - rightDistance ) );
	
	return ( IsTimedOut() || atTarget);
}
// Called once after isFinished returns true
void DriveStraightDistance::End() {
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveStraightDistance::Interrupted() {
}
