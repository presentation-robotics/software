// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Chassis.h"
#include "../Robotmap.h"
#include "../Commands/DriveTeleop.h"
Chassis::Chassis() : Subsystem("Chassis") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	leftDriveMotor = RobotMap::chassisLeftDriveMotor;
	leftDriveEncoder = RobotMap::chassisLeftDriveEncoder;
	leftDrivePID = RobotMap::chassisLeftDrivePID;
	rightDriveMotor = RobotMap::chassisRightDriveMotor;
	rightDriveEncoder = RobotMap::chassisRightDriveEncoder;
	rightDrivePID = RobotMap::chassisRightDrivePID;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	printf("2135: Chassis Constructor\n" );
	driveTrain = RobotMap::driveTrain;
	SmartDashboard::PutNumber("Left Setpoint", RobotMap::chassisLeftDrivePID->GetSetpoint());
	SmartDashboard::PutNumber("Right Setpoint", RobotMap::chassisRightDrivePID->GetSetpoint());
	SmartDashboard::PutNumber("Main Setpoint", 0);
	SmartDashboard::PutNumber("Left P", RobotMap::chassisLeftDrivePID->GetP());
	SmartDashboard::PutNumber("Right P", RobotMap::chassisRightDrivePID->GetP());
	SmartDashboard::PutNumber("Left Minimum", RobotMap::chassisLeftDrivePID->Get());
}
    
void Chassis::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveTeleop());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void Chassis::DriveWithJoystick(Joystick *driverJoystick){
	driveTrain->ArcadeDrive( driverJoystick, true );
}
void Chassis::DriveDistanceWithPIDInit(double distance){
	double leftDistance;
	double rightDistance;
	// get current encoder values
	leftDistance = leftDriveEncoder->GetDistance();
	rightDistance = rightDriveEncoder->GetDistance();
	// add distance to current encoder values
	leftDistance += distance;
	rightDistance += distance;
	// set SetPoint with calculated target distance
	RobotMap::chassisLeftDrivePID->SetSetpoint( leftDistance );
	RobotMap::chassisRightDrivePID->SetSetpoint( rightDistance );
	// enable PID
	RobotMap::chassisLeftDrivePID->Enable();
	RobotMap::chassisRightDrivePID->Enable();
}
void Chassis::DriveDistanceWithPIDExecute(){
}
bool Chassis::DriveDistanceWithPIDOnTarget(){
	bool bothOnTarget;
	// are both PIDs on target
	bothOnTarget = RobotMap::chassisLeftDrivePID->OnTarget() &&
					RobotMap::chassisRightDrivePID->OnTarget();
	return bothOnTarget;
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
