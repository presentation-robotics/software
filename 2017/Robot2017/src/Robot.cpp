// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "frc2135/VisionLoop.h"
#include "Commands/AutonDefault.h"
#include "Commands/AutonPos123Move.h"
#include "Commands/AutonPos1DeliverGear.h"
#include "Commands/AutonPos2DeliverGear.h"
#include "Commands/AutonPos3DeliverGear.h"
#include "Commands/AutonPos2VisionDeliverGear.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Chassis> Robot::chassis;
std::shared_ptr<Intake> Robot::intake;
std::shared_ptr<Agitator> Robot::agitator;
std::shared_ptr<Shooter> Robot::shooter;
std::shared_ptr<Delivery> Robot::delivery;
std::shared_ptr<Climber> Robot::climber;
std::shared_ptr<Pneumatics> Robot::pneumatics;
std::shared_ptr<Power> Robot::power;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

// Robot initialization - main startup sequence

void Robot::RobotInit() {

	//	Initialize all our devices and their IDs

	RobotMap::init();

	//	Create all of our subsystem objects

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    chassis.reset(new Chassis());
    intake.reset(new Intake());
    agitator.reset(new Agitator());
    shooter.reset(new Shooter());
    delivery.reset(new Delivery());
    climber.reset(new Climber());
    pneumatics.reset(new Pneumatics());
    power.reset(new Power());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	m_faultsCleared = false;

	prefs = frc::Preferences::GetInstance();

//	printf("2135: Main Thread ID %d\n", RobotBase::GetThreadId());
	std::thread m_vThread(VisionThread);
	m_vThread.detach();

	printf("2135: RobotInit - Finished\n");
}

/**
 * This function is called when the disabled mode is entered (startup or disable button)
 * You can use it to reset subsystems before shutting down.
 */

//	Disabled mode handlers

void Robot::DisabledInit(){
	m_faultsCleared = false;

	SmartDashboardStartChooser();
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();

	SmartDashboardUpdate(smartdashDisabledRate);

	static int ticks_per_print = 0;
	if (ticks_per_print++ % 100 == 0) {
		printf("2135: DisabledPeriodic %d\n", ticks_per_print / 100); 	// Testing only
	}

	// If RoboRIO User button is pressed, dump all CAN faults
	if (GetUserButton() && !m_faultsCleared) {
		m_faultsCleared = true;
		RobotFaultDump();
	}
}

//	Autonomous mode handlers

void Robot::AutonomousInit() {
	RobotModeInitialize();

	autonomousCommand.reset(chooser.GetSelected());
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();

	SmartDashboardUpdate(smartdashAutonRate);
}

//	Teleop mode handlers

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();

	RobotModeInitialize();
}

void Robot::TeleopPeriodic() {
	Scheduler::GetInstance()->Run();

	SmartDashboardUpdate(smartdashTeleopRate);
}

// Test mode (LiveWindow) handlers

void Robot::TestPeriodic() {
	lw->Run();

	SmartDashboardUpdate(smartdashLiveRate);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

//	Robot mode change - initialization of all subsystems

void Robot::RobotModeInitialize() {
	prefs = frc::Preferences::GetInstance();

	// Initialize SmartDashboard preferences
//	TODO: Disable subsystems that rely on Talons until working
	chassis->Initialize(prefs);
//	agitator->Initialize(prefs);
//	climber->Initialize(prefs);
	delivery->Initialize(prefs);
//	intake->Initialize(prefs);
	pneumatics->Initialize(prefs);
//	shooter->Initialize(prefs);
}

//	SmartDashboard - Autonomous chooser initialization

void Robot::SmartDashboardStartChooser() {
	return;		// TODO: fixme
	chooser.AddDefault("Auton Default", new AutonDefault());
	chooser.AddObject("Pos 123 Move", new AutonPos123Move());
	chooser.AddObject("Pos 1 Gear", new AutonPos1DeliverGear());
	chooser.AddObject("Pos 2 Gear", new AutonPos2DeliverGear());
	chooser.AddObject("Pos 3 Gear", new AutonPos3DeliverGear());
	chooser.AddObject("Pos 2 Gear Vision", new AutonPos2VisionDeliverGear());
	frc::SmartDashboard::PutData("Auto Modes", &chooser);
}

//	SmartDashboard - Data refresh routines

void Robot::SmartDashboardUpdate(int rate) {
	static int m_dashboardUpdate = 0;

	//	Print smart dashboard values only occasionally to reduce resource requirements
	if (m_dashboardUpdate++ > rate)
	{
		m_dashboardUpdate = 0;

		// Only chassis routines updated now
		Robot::chassis->UpdateSmartDashboardValues();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////

//	Fault handling utilities

void Robot::RobotFaultDump(void) {
	printf("2135: %s --------------\n", "TALON SRX FAULTS");
	RobotFaultDumpTalonSRX("chassisMotorL1", RobotMap::chassisMotorL1);
	RobotFaultDumpTalonSRX("chassisMotorL2", RobotMap::chassisMotorL2);
	RobotFaultDumpTalonSRX("chassisMotorR3", RobotMap::chassisMotorR3);
	RobotFaultDumpTalonSRX("chassisMotorR4", RobotMap::chassisMotorR4);
	RobotFaultDumpTalonSRX("intakeMotor8", RobotMap::intakeMotor8);
	RobotFaultDumpTalonSRX("intakeMotor9", RobotMap::intakeMotor9);
	RobotFaultDumpTalonSRX("agitatorMotor12", RobotMap::agitatorMotor12);
	RobotFaultDumpTalonSRX("shooterMotor14", RobotMap::shooterMotor14);
	RobotFaultDumpTalonSRX("climberMotor18", RobotMap::climberMotor18);
	RobotFaultDumpTalonSRX("climberMotor19", RobotMap::climberMotor19);

	printf("2135: %s --------------\n", "PCM FAULTS");
	if (RobotMap::pneumaticsCompressor->GetCompressorCurrentTooHighStickyFault())
		printf("\tCurrentTooHighFault\n");
	if (RobotMap::pneumaticsCompressor->GetCompressorNotConnectedFault())
		printf("\tCompressorNotConnectedFault\n");
	if (RobotMap::pneumaticsCompressor->GetCompressorShortedFault())
		printf("\tCompressorShortedFault\n");
	RobotMap::pneumaticsCompressor->ClearAllPCMStickyFaults();

	printf("2135: %s --------------\n", "PDP FAULTS");
	RobotMap::powerPDP->ClearStickyFaults();
}

void Robot::RobotFaultDumpTalonSRX(const char *talonName, std::shared_ptr<CAN::TalonSRX> talonPtr) {

	Faults			faults;
	StickyFaults	stickyFaults;

	talonPtr->GetFaults(faults);
	talonPtr->GetStickyFaults(stickyFaults);
	talonPtr->ClearStickyFaults(100);

	printf("2135: %s --------------\n", talonName);

	if (faults.HasAnyFault())
		printf("At Least one fault below\n");
	if (faults.HardwareFailure)
		printf("\tHardwareFailure\n");
	if (faults.OverTemp)
		printf("\tOverTemp\n");
	if (faults.UnderVoltage)
		printf("\tUnderVoltage\n");
	if (faults.ResetDuringEn)
		printf("\tResetDuringEn\n");
	if (faults.MsgOverflow)
		printf("\tMsgOverflow\n");
	if (faults.ForwardLimitSwitch)
		printf("\tForwardLimitSwitch\n");
	if (faults.ForwardSoftLimit)
		printf("\tForwardSoftLimit\n");
	if (faults.ReverseLimitSwitch)
		printf("\tForwardLimitSwitch\n");
	if (faults.ReverseSoftLimit)
		printf("\tForwardSoftLimit\n");

	if (stickyFaults.HasAnyFault())
		printf("At Least one STICKY fault below\n");
	if (stickyFaults.HardwareFailure)
		printf("\tHardwareFailure\n");
	if (stickyFaults.OverTemp)
		printf("\tOverTemp\n");
	if (stickyFaults.UnderVoltage)
		printf("\tUnderVoltage\n");
	if (stickyFaults.ResetDuringEn)
		printf("\tResetDuringEn\n");
	if (stickyFaults.MsgOverflow)
		printf("\tMsgOverflow\n");
	if (stickyFaults.ForwardLimitSwitch)
		printf("\tForwardLimitSwitch\n");
	if (stickyFaults.ForwardSoftLimit)
		printf("\tForwardSoftLimit\n");
	if (stickyFaults.ReverseLimitSwitch)
		printf("\tForwardLimitSwitch\n");
	if (stickyFaults.ReverseSoftLimit)
		printf("\tForwardSoftLimit\n");

}

///////////////////////////////////////////////////////////////////////////////////////////////////

//	Preference handling utilities

double Robot::LoadPreferencesVariable(std::string name, double defaultValue) {
	double value;
	Preferences *prefs;

	prefs = frc::Preferences::GetInstance();

	if (prefs->ContainsKey(name)) {
		value = prefs->GetDouble(name, defaultValue);
		printf("2135: PREF    %-30s : %6.3f\n", name.c_str(), value);
	}
	else {
		value = defaultValue;
		printf("2135: WARNING %-30s not found\n", name.c_str());
	}

	return value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

// Vision Thread to call into our Vision processing loop

void VisionThread() {
	// Thread checking
	printf("2135: ----- VISION THREAD RUNNING -----\n");
//	printf("2135: Vision Thread ID %d\n", std::this_thread::get_id());
	if (std::this_thread::get_id() == RobotBase::GetThreadId()) {
		printf("2135: ERROR: Vision Loop cannot be called from the main robot thread\n");
		return;
	}

	try {
		// Instantiate the vision loop and call it
		VisionLoop *vision = new VisionLoop;
		vision->Run();

		// Should never get here - if it does then clean up
		delete vision;
	}
	catch (...) {	// Error detected, loop in a sleep mode (return seems to reboot robot)
		while(1) {
			printf("2135: Vision Thread terminated due to exception\n");
			std::this_thread::sleep_for(std::chrono::seconds(10));
		}
	}
}

START_ROBOT_CLASS(Robot);
