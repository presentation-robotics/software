// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Chassis.h"
#include "../RobotMap.h"
#include "../Commands/DriveTeleop.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Chassis::Chassis() : Subsystem("Chassis") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motorL1 = RobotMap::chassisMotorL1;
    motorR3 = RobotMap::chassisMotorR3;
    robotDrive = RobotMap::chassisRobotDrive;
    motorL2 = RobotMap::chassisMotorL2;
    motorR4 = RobotMap::chassisMotorR4;
    shifter = RobotMap::chassisShifter;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    gyro = RobotMap::chassisGyro;

    printf("2135: Chassis Constructor\n");

    // Note that we cannot load smartdashboard values here - driverstation may not be connected yet

    // Drivetrain Talon settings - Teleop mode

    // TODO: Safety cannot remain disabled for competition code
    robotDrive->SetSafetyEnabled(false);

    // Make second Talon SRX controller on each side of drivetrain follow the main Talon SRX
    motorL2->SetTalonControlMode(CANTalon::TalonControlMode::kFollowerMode);
    motorL2->Set(1);
    motorR4->SetTalonControlMode(CANTalon::TalonControlMode::kFollowerMode);
    motorR4->Set(3);

    // Drivetrain Talon settings - Autonomous modes

    // Feedback device is US Digital S4 CPR 360 encoder
	motorL1->SetFeedbackDevice(CANTalon::QuadEncoder);
	motorR3->SetFeedbackDevice(CANTalon::QuadEncoder);
	motorL1->ConfigEncoderCodesPerRev(USDigitalS4_CPR_120);
	motorR3->ConfigEncoderCodesPerRev(USDigitalS4_CPR_120);

    // Invert the direction of the right hand side motors and sensors
	motorL1->SetClosedLoopOutputDirection(false);
	motorR3->SetClosedLoopOutputDirection(true);
	motorL1->SetSensorDirection(true);
	motorR3->SetSensorDirection(false);

    // Set all motors to use coast mode and not brake when stopped
    m_brakeMode = false;
    MoveSetBrakeNotCoastMode(m_brakeMode);

	// Autonomous turn PID controller
    turnOutput = new TurnOutput(robotDrive);
    turnControl = new PIDController(0.1, 0.0, 0.0, gyro.get(), turnOutput);

	//	Initialize drivetrain modifiers
    m_driveDirection = 1.0;			// Initialize drivetrain direction for driving forward or backward
    m_driveScalingFactor = 1.0;		// Initialize scaling factor and disable it
    m_driveSpinSetting = 0.45;		// Initialize power setting used for spin turns

    // 	Initialize closed loop parameters for Talon PID - ramp rate, close loop error, target rotations
    m_pidCloseLoopRamp = 0.0;
    m_pidAllowCloseLoopError = 0.0;
    m_pidTargetRotations = 0.0;

    // Initialize to high gear
    m_lowGear = false;

    // TODO: Calibrate gyro - this is believed to take a few seconds--must be in constructor
    printf("2135: Starting gyro calibration\n");
	gyro->Calibrate();
    printf("2135: Stopping gyro calibration\n");
}

void Chassis::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveTeleop());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.


// Initialize is called whenever we change robot modes Disabled->Teleop, Disabled->Autonomous
//	It is used to reinitialize the chassis settings to a known condition and read smartdashboard changes

void Chassis::Initialize(frc::Preferences *prefs)
{
	// Initialize SmartDashboard values - if any

	printf("2135: Chassis Initialize\n");

	// Drive invert direction the stick moves the robot
	SmartDashboard::PutNumber("DriveInvert", m_driveDirection);

	// Brake/coast mode for talon speed controller
    MoveSetBrakeNotCoastMode(m_brakeMode);

	// Scale maximum driving speed - beginner mode
	m_driveScalingFactor = Robot::LoadPreferencesVariable("ChsDriveScaling", 1.0);
	SmartDashboard::PutNumber("DriveScaling", m_driveScalingFactor);

	// Speed to apply to the motors for spin turns
	m_driveSpinSetting = Robot::LoadPreferencesVariable("ChsDriveSpin", 0.4);
	SmartDashboard::PutNumber("DriveSpin", m_driveSpinSetting);

	// Closed Loop VoltageRampRate
	// TODO: This seems to be copied from an old robot--we should try NO ramp rate first
	m_pidCloseLoopRamp = Robot::LoadPreferencesVariable("ChsCL_RampRate", 8.0);
	SmartDashboard::PutNumber("CL_RampRate", m_pidCloseLoopRamp);
//	motorL1->SetCloseLoopRampRate(m_driveCloseLoopRamp);
//	motorR3->SetCloseLoopRampRate(m_pidCloseLoopRamp);

	// absTolerance - in rotations
	// TODO: This seems to be copied from an old robot--we should try NO tolerance first
	//	AND the units seem to be WRONG from what the reference manual states-- should be in CPR*4
	m_pidAllowCloseLoopError = Robot::LoadPreferencesVariable("ChsCL_AllowError", 0);
	SmartDashboard::PutNumber("CL_AllowError", m_pidAllowCloseLoopError);
//	motorL1->SetAllowableClosedLoopErr(m_absTolerance);
//	motorR3->SetAllowableClosedLoopErr(m_absTolerance);

	// left right encoder values
	motorL1->SetEncPosition(0);
	motorR3->SetEncPosition(0);

	// peakOutput
	// TODO: This seems to be copied from an old robot--we should either COMMENT this or disable by setting to 12.0
	SmartDashboard::PutNumber("CL_PeakOutVolts", Robot::LoadPreferencesVariable("ChsCL_PeakOutVolts", 5.0));

	// proportional
	// TODO: This seems to be copied from an old robot--it is too low for the PID loop. Should be ~2.5 to 5.0 ish
	SmartDashboard::PutNumber("CL_Proportional", Robot::LoadPreferencesVariable("ChsCL_Proportional", 3.5));

	// drive distance inches
	// TODO: We should have the default distance be something safer like 5 ft max (60 inches)
	SmartDashboard::PutNumber("DriveDistance", 60);

	// reset gyro to zero
	gyro->Reset();

	// drive heading angle
	SmartDashboard::PutNumber("DriveHeadingAngle", 0.0);

//	TODO: Not a great place to be hard-coding these values Put them near where the values are set--if needed at all
	// We put the smartdashboard controls in to keep from having to do exactly this stuff
	// TEST - Kp
//	SmartDashboard::PutNumber("CL_Proportional", 0.3);

	// TEST - Nominal Output Voltage
//	SmartDashboard::PutNumber("CL_NomOutVolts", 0.0);
}


// UpdateSmartDashboardValues is used during TelopPeriodic and AutonomousPeriodic to display real time updates
//	of sensor values

void Chassis::UpdateSmartDashboardValues(void)
{
	// TODO: Verify for correct values
	SmartDashboard::PutNumber("ChsL_EncPosition", motorL1->GetEncPosition());
	SmartDashboard::PutNumber("ChsR_EncPosition", motorR3->GetEncPosition());
	SmartDashboard::PutNumber("ChsL_Rotations", motorL1->GetPosition());
	SmartDashboard::PutNumber("ChsR_Rotations", motorR3->GetPosition());
	SmartDashboard::PutNumber("ChsL_CLError", motorL1->GetClosedLoopError());
	SmartDashboard::PutNumber("ChsR_CLError", motorR3->GetClosedLoopError());
	SmartDashboard::PutNumber("ChsGyroAngle", gyro->GetAngle());
}

///////////////////////////////////////////////////////////////////////////////////////////////////

//	Drivetrain and movement methods

// MoveWithJoystick is our main Teleop control of ArcadeDrive

void Chassis::MoveWithJoystick(std::shared_ptr<Joystick> joystick)
{
	double xValue;
	double yValue;

	// Retrieve the joystick values, if inverted drive is selected, flip the Y input
	xValue = joystick->GetX();
	yValue = joystick->GetY() * m_driveDirection;

	// If in high gear, use the scaling factor against the y-axis
	// TODO: Why does scaling affect the X axis? Should it? (Maybe it's correct)
	if (!m_lowGear) {
		xValue = xValue * m_driveScalingFactor;
		yValue = yValue * m_driveScalingFactor;
	}

	// Apply modified joystick input to the drive motors
	robotDrive->ArcadeDrive( xValue, yValue, true );
}

// MoveSpin is a custom feature that can be hooked to a button for spin turns

void Chassis::MoveSpin(bool spinLeft)
{
	// Use input flag to perform a left/right turn using equal power, opposite direction on motors
	if (spinLeft)
		robotDrive->SetLeftRightMotorOutputs( -m_driveSpinSetting, m_driveSpinSetting );
	else
		robotDrive->SetLeftRightMotorOutputs( m_driveSpinSetting, -m_driveSpinSetting );
}

// MoveInvertDriveDirection is a custom feature to set robot drive direction to flip from front to back

void Chassis::MoveInvertDriveDirection(void)
{
	// Toggle the drive direction and update the dashboard status
	m_driveDirection = -m_driveDirection;
	SmartDashboard::PutNumber("DriveInvert", m_driveDirection);
}

// MoveSetBrakeNotCoastMode is used to allow other functions and commands to change how the drive works

void Chassis::MoveSetBrakeNotCoastMode(bool brakeMode)
{
	// If brake mode is requested, send to the Talons
	if (brakeMode) {
		motorL1->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Brake);
		motorL2->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Brake);
		motorR3->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Brake);
		motorR4->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Brake);
	}
	else {
		motorL1->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Coast);
		motorL2->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Coast);
		motorR3->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Coast);
		motorR4->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Coast);
	}

	// Update the global setting
	m_brakeMode = brakeMode;
	SmartDashboard::PutBoolean("DriveBrakeMode", brakeMode);
}

// MoveUsingMotorOutputs is used to allow other functions to control the drive with direct left/right inputs

void Chassis::MoveUsingMotorOutputs(double motorInputLeft, double motorInputRight)
{
	robotDrive->SetLeftRightMotorOutputs(motorInputLeft, motorInputRight);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

//	Closed loop movement - Drive a distance using PID loop in Talons

// MoveDriveDistancePIDInit is used at the beginning of distance PID command to start the PID loop in the Talon

void Chassis::MoveDriveDistancePIDInit(double inches)
{
//	double closeLoopRampRate;
//	double peakOutputVoltage;
//	double nominalOutputVoltage;
	double proportional;

	m_pidTargetRotations = inches / (WheelDiaInches * M_PI);
	printf("2135: Encoder Distance %f rotations, %f inches\n", m_pidTargetRotations, inches);

	// TODO: Experiment to get default values
//	closeLoopRampRate = SmartDashboard::GetNumber("CL_RampRate", 8.0);
//	peakOutputVoltage = SmartDashboard::GetNumber("CL_PeakOutVolts", 5.0);
//	nominalOutputVoltage = SmartDashboard::GetNumber("CL_NomOutVolts", 0.0);
	proportional = SmartDashboard::GetNumber("CL_Proportional", 3.6);

	// Shift into low gear during movement for better accuracy
	MoveShiftGears(true);

	// Change the drive motors to be position-loop control modes
	motorL1->SetTalonControlMode(CANTalon::TalonControlMode::kPositionMode);
	motorR3->SetTalonControlMode(CANTalon::TalonControlMode::kPositionMode);

	// Change to brake mode
	MoveSetBrakeNotCoastMode(true);

	// Temporarily adjust voltage ramp rate for this year's robot
//	motorL1->SetCloseLoopRampRate(closeLoopRampRate);
//	motorR3->SetCloseLoopRampRate(closeLoopRampRate);

	// Adjust peak output voltage for this year's robot
//	motorL1->ConfigPeakOutputVoltage(peakOutputVoltage, -peakOutputVoltage);
//	motorR3->ConfigPeakOutputVoltage(peakOutputVoltage, -peakOutputVoltage);

	// Adjust nominal output voltage for their year's robot -- TEST
//	motorL1->ConfigNominalOutputVoltage(nominalOutputVoltage, -nominalOutputVoltage);
//	motorR3->ConfigNominalOutputVoltage(nominalOutputVoltage, -nominalOutputVoltage);

	// This should be set one time in constructor
	motorL1->SetPID(proportional, 0.0, 0.0);
	motorR3->SetPID(proportional, 0.0, 0.0);

	// Initialize the encoders to start movement at reference of zero counts
	motorL1->SetEncPosition(0);
	motorR3->SetEncPosition(0);

	// Set the target distance in terms of wheel rotations
	motorL1->Set(m_pidTargetRotations);
	motorR3->Set(m_pidTargetRotations);

	// Enable the PID loop to start the movement
	motorL1->Enable();
	motorR3->Enable();

	//Start safety timer
	m_safetyTimer.Reset();
	m_safetyTimer.Start();

	// Disable safety feature during movement, since motors will be fed by loop
	robotDrive->SetSafetyEnabled(false);
}

// MoveDriveDistancePIDExecuted is called repeatedly until the PID loop reaches the target

void Chassis::MoveDriveDistancePIDExecute(void)
{
//	//Verify that robot has reached target within absolute tolerance margins
//	if (abs(m_rotations - motorL1->GetPosition()) <= m_absToleranceRotations) {
//		//printf("2135: Left PID disabled\n");
//	}
//
//	if (abs(m_rotations - motorR3->GetPosition()) <= m_absToleranceRotations) {
//		//printf("2135: Right PID disabled\n");
//	}
}

bool Chassis::MoveDriveDistanceIsPIDAtSetpoint(void)
{
	// Verify that both encoders are on target
	bool bothOnTarget = false;
//	double leftDifference;
//	double rightDifference;

//	// Calculate difference of target rotations minus actual position (called the "error")
//	leftDifference = m_pidTargetRotations - motorL1->GetPosition();
//	rightDifference = m_pidTargetRotations - motorR3->GetPosition();
//
//	// If both left and right differences are within our tolerance
//	if ((abs(leftDifference) <= m_pidAllowCloseLoopError/(USDigitalS4_CPR_120*4)) &&
//		(abs(rightDifference) <= m_pidAllowCloseLoopError/(USDigitalS4_CPR_120*4))) {
//
//		printf("2135: TargetRotations: %3.2f < %3.2f < %3.2f\n", m_pidTargetRotations-m_pidAllowCloseLoopError,
//			m_pidTargetRotations, m_pidTargetRotations+m_pidAllowCloseLoopError);
//		printf("2135: Position Rotations L: %3.2f  R: %3.2f\n", motorL1->GetPosition(), motorR3->GetPosition());
//		printf("2135: Difference         L: %3.2f  R: %3.2f\n", leftDifference, rightDifference);
//
//		bothOnTarget = true;
//	}

	if ((motorL1->GetClosedLoopError() < 30) && (motorR3->GetClosedLoopError() < 30)) {
		printf("2135: TargetRotations: %3.2f\n", m_pidTargetRotations);
		printf("2135: Position Rotations L: %3.2f  R: %3.2f\n", motorL1->GetPosition(), motorR3->GetPosition());
		bothOnTarget = true;
	}

	// If on target or timer has passed 3.0 seconds
	// TODO: can't really use a distance, because PID will not move at full speed always
//	return bothOnTarget || (m_safetyTimer.HasPeriodPassed((m_safetyInches/78)+1));
	return bothOnTarget || (m_safetyTimer.HasPeriodPassed(10.0));
}

// MoveDriveDistancePIDStop is called to clean up after the PID loop reaches the target position

void Chassis::MoveDriveDistancePIDStop(void)
{
	// Stop the safety timer
	m_safetyTimer.Stop();

	// Disable the PID loop
	motorL1->Disable();
	motorR3->Disable();

	// Change back to gear setting default
	MoveShiftGears(false);

	// Change to coast mode
	MoveSetBrakeNotCoastMode(false);

	// Change from PID position-loop back to PercentVbus for driver control
	motorL1->SetTalonControlMode(CANTalon::TalonControlMode::kThrottleMode);
	motorR3->SetTalonControlMode(CANTalon::TalonControlMode::kThrottleMode);

	// Re-enable the motor safety helper
	robotDrive->SetSafetyEnabled(true);
}


///////////////////////////////////////////////////////////////////////////////////////////////////

//	Closed loop movement - Drive to a relative heading using PID loop in RoboRIO

void Chassis::MoveDriveHeadingDistance(double inches, double angle)
{
	// Program the PID target setpoint
	turnControl->SetSetpoint(angle);
	printf("===> MoveDriveHeadingDistance() using angle: %f\n",angle);

	// Shift into low gear during movement for better accuracy
	MoveShiftGears(true);

	// Enable the PID loop
	turnControl->SetOutputRange(-0.8, 0.8);
	turnControl->SetAbsoluteTolerance(2.0);
	turnControl->Enable();

	//Start safety timer
	m_safetyTimer.Reset();
	m_safetyTimer.Start();
}

bool Chassis::MoveDriveHeadingIsPIDAtSetPoint(void) {
	// Test the PID to see if it is on the programmed target
	return (turnControl->OnTarget()); // || (m_safetyTimer.HasPeriodPassed(10.0));
}

void Chassis::MoveDriveHeadingStop(void) {
	// Disable PID loop
	turnControl->Disable();

	// Stop safety timer
	m_safetyTimer.Stop();

	// Shift back into high gear
	MoveShiftGears(false);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

//	Drivetrain movement - Allow other functions to shift gears to low/high as requested

void Chassis::MoveShiftGears(bool lowGear)
{
	if (lowGear) {
		shifter->Set(shifter->kForward);
		m_lowGear = true;
	}
	else {
		shifter->Set(shifter->kReverse);
		m_lowGear = false;
	}
}
