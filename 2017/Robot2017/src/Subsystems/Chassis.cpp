// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Chassis.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Chassis::Chassis() : Subsystem("Chassis") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motorL2 = RobotMap::chassisMotorL2;
    motorL3 = RobotMap::chassisMotorL3;
    motorR4 = RobotMap::chassisMotorR4;
    motorR5 = RobotMap::chassisMotorR5;
    analogGyro1 = RobotMap::chassisAnalogGyro1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Chassis::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Chassis::MoveWithJoystick(std::shared_ptr<Joystick> joystick)
{
	double xValue;
	double yValue;

	xValue = joystick->GetX() * -1;
	yValue = joystick->GetY() + m_driveDirection;

	if(m_scaled) {
		xValue = xValue * m_driveScalingFactor;
		yValue = yValue * m_driveScalingFactor;
	}

	robotDrive->ArcadeDrive( yValue, xValue, true );
}

void Chassis::SetVoltRampRate(double voltageRampRate)
{
	motorL2->SetVoltageRampRate(voltageRampRate);
	motorR4->SetVoltageRampRate(voltageRampRate);
}

void Chassis::MoveLowShift(bool scaled)
{
	m_scaled = scaled;

}

void Chassis::MoveSpin(bool spinLeft)
{
	if (spinLeft)
		robotDrive->SetLeftRightMotorOutputs( -m_driveSpinSetting, m_driveSpinSetting );
	else
		robotDrive->SetLeftRightMotorOutputs( m_driveSpinSetting, -m_driveSpinSetting );


}

void Chassis::MoveStop(void)
{
	robotDrive->SetLeftRightMotorOutputs( 0.0, 0.0 );
}

void Chassis::ReverseDriveTrain(void)
{
	m_driveDirection = -m_driveDirection;
	SmartDashboard::PutNumber("Drive Invert", m_driveDirection);

}

double Chassis::ReadGyro(void)
{
	return analogGyro1->GetAngle();
}

void Chassis::ResetGyro(void)
{
	analogGyro1->Reset();
}
