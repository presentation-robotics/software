// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Subsystems/Drivetrain.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

#include "Commands/DriveTeleop.h"


Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {

    std::printf("2135: DT Drivetrain Constructor");

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motorL1.reset(new WPI_TalonSRX(1));
    motorR3.reset(new WPI_TalonSRX(3));
    diffDrive.reset(new frc::DifferentialDrive(*motorL1, *motorR3));
    motorL2.reset(new WPI_TalonSRX(2));
    motorR4.reset(new WPI_TalonSRX(4));
    shifter.reset(new frc::DoubleSolenoid(0, 0, 7));
    driveEncoderL1.reset(new frc::Encoder(0, 1, false, frc::Encoder::k4X));
    driveEncoderR3.reset(new frc::Encoder(2, 3, false, frc::Encoder::k4X));
    pigeonIMU.reset(new PigeonIMU(0));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Validate Talon SRX controllers, initialize and display firmware versions
    m_talonValidL1 = frc2135::TalonSRXUtils::TalonSRXCheck(motorL1, "DT", "L1");
    m_talonValidL2 = frc2135::TalonSRXUtils::TalonSRXCheck(motorL2, "DT", "L2");
    m_talonValidR3 = frc2135::TalonSRXUtils::TalonSRXCheck(motorR3, "DT", "R3");
    m_talonValidR4 = frc2135::TalonSRXUtils::TalonSRXCheck(motorR4, "DT", "R4");

    // Retrieve drivetrain modified parameters from RobotConfig
     frc2135::RobotConfig* config = frc2135::RobotConfig::GetInstance();
     config->GetValueAsDouble("DT_DriveXScaling", m_driveXScaling, 1.0);
 	 config->GetValueAsDouble("DT_DriveYScaling", m_driveYScaling, 1.0);
    

    // Invert the direction of the motors
    // Set to coast mode (in comparison to brake)
    // Set encoder as a CTRE magnetic in relative mode with sensor in phase with output
    if (m_talonValidL1) {
        motorL1->SetInverted(true);
        motorL1->SetNeutralMode(NeutralMode::Coast);
        motorL1->Set(ControlMode::PercentOutput, 0.0);
        motorL1->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, m_pidIndex, m_timeout);
        motorL1->SetSensorPhase(false);
        motorL1->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);
    }

    if (m_talonValidL2) {
    	motorL2->SetInverted(true);
        motorL2->SetNeutralMode(NeutralMode::Coast);
        motorL2->Set(ControlMode::Follower, 1);
    }

    if (m_talonValidR3) {
        motorR3->SetInverted(true);
        motorR3->SetNeutralMode(NeutralMode::Coast);
        motorR3->Set(ControlMode::PercentOutput, 0.0);
        motorR3->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, m_pidIndex, m_timeout);
        motorR3->SetSensorPhase(false);
        motorR3->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);
    }

    if (m_talonValidR4) {
        motorR4->SetInverted(true);
        motorR4->SetNeutralMode(NeutralMode::Coast);
        motorR4->Set(ControlMode::Follower, 3);
    }

    // Set to low gear (default)
    m_lowGear = true;
    MoveShiftGears(m_lowGear);

    // If both drive talons not valid, disable safety timer
    if (m_talonValidL1 || m_talonValidR3) {
        diffDrive->SetSafetyEnabled(true);
    }
    else {
        diffDrive->SetSafetyEnabled(false);
    }
   	
}

void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveTeleop());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {
    // Put code here to be run every loop
    double	encoderLeft = 0.0;
	double	encoderRight = 0.0;
    double	outputL1 = 0.0, currentL1 = 0.0;
	double	outputL2 = 0.0, currentL2 = 0.0;
	double	outputR3 = 0.0, currentR3 = 0.0;
	double	outputR4 = 0.0, currentR4 = 0.0;

    if (m_talonValidL1) {
		encoderLeft = motorL1->GetSelectedSensorPosition(0);
		outputL1 = motorL1->GetMotorOutputPercent();
		currentL1 = motorL1->GetOutputCurrent();
	}

	if (m_talonValidL2) {
		outputL2 = motorL2->GetMotorOutputPercent();
		currentL2 = motorL2->GetOutputCurrent();
	}

	if (m_talonValidR3) {
		encoderRight = motorR3->GetSelectedSensorPosition(0);
		outputR3 = motorR3->GetMotorOutputPercent();
		currentR3 = motorR3->GetOutputCurrent();
	}

	if (m_talonValidR4) {
		outputR4 = motorR4->GetMotorOutputPercent();
		currentR4 = motorR4->GetOutputCurrent();
	}
    
    if (m_driveDebug) {
		frc::SmartDashboard::PutNumber("DT_Encoder_L", encoderLeft);
		frc::SmartDashboard::PutNumber("DT_Output_L1", outputL1);
		frc::SmartDashboard::PutNumber("DT_Current_L1", currentL1);
		frc::SmartDashboard::PutNumber("DT_Output_L2", outputL2);
		frc::SmartDashboard::PutNumber("DT_Current_L2", currentL2);

		frc::SmartDashboard::PutNumber("DT_Encoder_R", encoderRight);
		frc::SmartDashboard::PutNumber("DT_Output_R3", outputR3);
		frc::SmartDashboard::PutNumber("DT_Current_R3", currentR3);
		frc::SmartDashboard::PutNumber("DT_Output_R4", outputR4);
		frc::SmartDashboard::PutNumber("DT_Current_R4", currentR4);
    }
}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

////////////////////////////////////////////////////////////////////////////////////////

// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drivetrain::Initialize(void) {
	std::printf("2135: DT Initialize\n");

	// When disabled, low gear and coast mode to allow easier pushing
	if (frc::RobotState::IsDisabled()) {
		m_lowGear = true;
		m_brakeMode = false;
	}
	else {
		// Enabled and teleop - low gear and coast mode
		if (frc::RobotState::IsOperatorControl()) {
			m_lowGear = true;
			m_brakeMode = false;
		}
		else {	// Auton always low gear and brake mode
			m_lowGear = true;
			m_brakeMode = true;
		}
	}

	MoveShiftGears(m_lowGear);
    MoveSetBrakeMode(m_brakeMode);
}

//	Joystick movement during Teleop

void Drivetrain::MoveWithJoystick(std::shared_ptr<frc::Joystick> throttleJstick, std::shared_ptr<frc::Joystick> turnJstick) {
	double xValue;
	double yValue;

    if (turnJstick = nullptr) {
        xValue = throttleJstick->GetX();
	    yValue = throttleJstick->GetZ();
    }
    else {
        xValue = turnJstick->GetX();
	    yValue = throttleJstick->GetY();
    }

    xValue *= m_driveXScaling;
	if (!m_lowGear) {
		yValue *= m_driveYScaling;
	}

	if (m_talonValidL1 && m_talonValidR3)
		diffDrive->ArcadeDrive(-yValue, xValue, true);
}

//	Shift transmission gears

void Drivetrain::MoveShiftGears(bool lowGear) {
    m_lowGear = lowGear;

    std::printf("2135: DT %s Gear\n", (lowGear) ? "LOW" : "HIGH");
    frc::SmartDashboard::PutBoolean("DT Low Gear", lowGear);

    shifter->Set( (lowGear) ? shifter->kForward : shifter->kReverse);
}

//	Set Talon brake mode

void Drivetrain::MoveSetBrakeMode(bool brakeMode) {
	m_brakeMode = brakeMode;

	std::printf("2135: DT %s Mode\n", (brakeMode) ? "BRAKE" : "COAST");
	frc::SmartDashboard::PutBoolean("DT Brake Mode", brakeMode);

	NeutralMode brakeOutput;
	brakeOutput = (brakeMode) ? NeutralMode::Brake : NeutralMode::Coast;
	if (m_talonValidL1)
		motorL1->SetNeutralMode(brakeOutput);
	if (m_talonValidL2)
		motorL2->SetNeutralMode(brakeOutput);
	if (m_talonValidR3)
		motorR3->SetNeutralMode(brakeOutput);
	if (m_talonValidR4)
		motorR4->SetNeutralMode(brakeOutput);
}
