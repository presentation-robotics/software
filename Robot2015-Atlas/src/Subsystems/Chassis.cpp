// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Chassis.h"
#include "../Robotmap.h"
#include "../Commands/DriveTeleop.h"
Chassis::Chassis() : Subsystem("Chassis") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	ultrasonicDrive = RobotMap::chassisUltrasonicDrive;
	lEDRelay = RobotMap::chassisLEDRelay;
	leftDriveMotor = RobotMap::chassisLeftDriveMotor;
	leftDriveEncoder = RobotMap::chassisLeftDriveEncoder;
	leftDrivePID = RobotMap::chassisLeftDrivePID;
	rightDriveMotor = RobotMap::chassisRightDriveMotor;
	rightDriveEncoder = RobotMap::chassisRightDriveEncoder;
	rightDrivePID = RobotMap::chassisRightDrivePID;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	printf("2135: Chassis Constructor\n");
	drvTrain = RobotMap::driveTrain;
	m_orientationNormal = 1.0;
	drvTrain->SetInvertedMotor(RobotDrive::kRearLeftMotor, true);
	drvTrain->SetInvertedMotor(RobotDrive::kRearRightMotor, true);
	drvTrain->SetExpiration(2.0);
	m_speedTimer = new Timer;
	m_speedTimer->Start();
	ultrasonicDrive->SetAutomaticMode(true);
	ultrasonicDrive->SetEnabled(true);
	//accel = new ADXL345_I2C(1);
}
void Chassis::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveTeleop());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
//
//	Normal Teleop Drive using Joysticks in Arcade mode
//
void Chassis::DriveWithJoystick( Joystick *driverJoystick )
{
#if 1 // Slow not child mode
	drvTrain->ArcadeDrive( driverJoystick, true );
#else
	drvTrain->ArcadeDrive( driverJoystick->GetY() * m_orientationNormal * 0.75, driverJoystick->GetX() * 0.75, true );
#endif // SmartDashboard::
}
//
//	Controlled drive used during spin turns
//
void Chassis::DriveUsingLeftRightMotorOutputs( double left, double right )
{
	// printf ( "2135: SetLeftRightMotorOutputs left - %6.3f, right - %6.3f\n", left, right );
	drvTrain->SetLeftRightMotorOutputs(left, right);
}
//
//	Reverse drive train for driving backwards
//
void Chassis::ReverseDriveTrain( void ) 
{
	m_orientationNormal = -m_orientationNormal;
#if 0 // SmartDashboard::
	SmartDashboard::PutNumber("Drive Invert", m_orientationNormal);
#endif // SmartDashboard::
}
//
//	Autonomous Drive to a specific distance - PID initialization
//
void Chassis::DriveDistanceWithPIDInit( double distance ) 
{
	double leftDistance;
	double rightDistance;
#if 0 // SmartDashboard::
	leftDrivePID->SetPID(SmartDashboard::GetNumber("L: P"),SmartDashboard::GetNumber("L: I"),
			SmartDashboard::GetNumber("L: D"));
#else // SmartDashboard::
	leftDrivePID->SetPID(0.1,0.0,0.0);
#endif // SmartDashboard::
	leftDrivePID->SetOutputRange(-0.6, 0.6);
	leftDrivePID->SetAbsoluteTolerance(0.2);
	leftDriveEncoder->SetDistancePerPulse(4 * M_PI / 360);
#if 0 // SmartDashboard::
	rightDrivePID->SetPID(SmartDashboard::GetNumber("R: P"),SmartDashboard::GetNumber("R: I"),
			SmartDashboard::GetNumber("R: D"));
#else // SmartDashboard::
	rightDrivePID->SetPID(0.1,0.0,0.0);
#endif // SmartDashboard::
	rightDrivePID->SetOutputRange(-0.6, 0.6);
	rightDrivePID->SetAbsoluteTolerance(0.2);
	rightDriveEncoder->SetDistancePerPulse(4 * M_PI / 360);
	// get current encoder values
	leftDistance = leftDriveEncoder->GetDistance();
	rightDistance = rightDriveEncoder->GetDistance();
	// add distance to current encoder values
	leftDistance += distance;
	rightDistance -= distance;
#if 0 // SmartDashboard::
	SmartDashboard::PutNumber("Left Setpoint", leftDistance);
	SmartDashboard::PutNumber("Right Setpoint", -rightDistance);
#endif // SmartDashboard::
	// set SetPoint with calculated target distance
	leftDrivePID->SetSetpoint(leftDistance);
	rightDrivePID->SetSetpoint(rightDistance);
	drvTrain->SetSafetyEnabled(false);
	// enable PID loops
	leftDrivePID->Enable();
	rightDrivePID->Enable();
#if 0 // SmartDashboard::
	SmartDashboard::PutBoolean("Left PID State", false);
	SmartDashboard::PutBoolean("Right PID State", false);
#endif // SmartDashboard::
}
//
//	Autonomous Drive to a specific distance - called from command execute
//
void Chassis::DriveDistanceWithPIDExecute( void ) 
{
	if (leftDrivePID->OnTarget()) {
#if 0 // SmartDashboard::
		SmartDashboard::PutBoolean("Left PID State", true);
#endif // SmartDashboard::
		leftDrivePID->Disable();
	}
	if (rightDrivePID->OnTarget()) {
#if 0 // SmartDashboard::
		SmartDashboard::PutBoolean("Right PID State", true);
#endif // SmartDashboard::
		rightDrivePID->Disable();
	}
	if (!leftDrivePID->IsEnabled())
		leftDriveMotor->Set(0, 0);
	if (!rightDrivePID->IsEnabled())
		rightDriveMotor->Set(0, 0);
}
//
//	Autonomous Drive to a specific distance - detect when at setpoint
//
bool Chassis::DriveDistanceWithPIDIsAtSetpoint( void )
{
	bool bothOnTarget;
	// are both PIDs on target
	bothOnTarget = false;
	if (!leftDrivePID->IsEnabled() && !rightDrivePID->IsEnabled()) {
		DriveDistanceWithPIDStop();
		bothOnTarget = true;
	}
	return bothOnTarget;
}
//
//	Autonomous Drive to a specific distance - stop the PID loop
//
void Chassis::DriveDistanceWithPIDStop( void )
{
#if 0 // SmartDashboard::
	SmartDashboard::PutBoolean("Left PID State", true);
	SmartDashboard::PutBoolean("Right PID State", true);
#endif // SmartDashboard::
	leftDrivePID->Disable();
	rightDrivePID->Disable();
	drvTrain->SetSafetyEnabled(true);
}
double Chassis::GetLeftSpeed( void ) 
{
	double static leftDistanceOld;
	double leftDistanceNew;
	double static timeOld;
	double timeNew;
	double leftSpeed;
	leftDistanceNew = leftDriveEncoder->GetDistance();
	timeNew = m_speedTimer->Get();
	leftSpeed = (leftDistanceNew - leftDistanceOld) / (timeNew - timeOld);
	leftDistanceOld = leftDistanceNew;
	timeOld = timeNew;
	return ((leftSpeed) / 12);
}
double Chassis::GetRightSpeed( void ) 
{
	double static rightDistanceOld;
	double rightDistanceNew;
	double static timeOld;
	double timeNew;
	double rightSpeed;
	rightDistanceNew = rightDriveEncoder->GetDistance();
	//double distanceArray[] {d0, d1, d2, d3, d4};
	//double timeArray[] {t0, t1, t2, t3, t4};
	//distanceArray[4] = distanceArray[0];
	timeNew = m_speedTimer->Get();
	rightSpeed = ((rightDistanceNew - rightDistanceOld) / (timeNew - timeOld)) * -1; 
	rightDistanceOld = rightDistanceNew;
	timeOld = timeNew;
	return ((rightSpeed) / 12);
}
double Chassis::GetLeftSpeedAverage( void )
{
	static double oldValues[4];
	oldValues[3] = oldValues[2];
	oldValues[2] = oldValues[1];
	oldValues[1] = oldValues[0];
	oldValues[0] = Robot::chassis->GetLeftSpeed();
	return (oldValues[3] + oldValues[2] + oldValues[1] + oldValues[0]) / 4;
}
double Chassis::GetRightSpeedAverage( void )
{
	static double oldValues[4];
	oldValues[3] = oldValues[2];
	oldValues[2] = oldValues[1];
	oldValues[1] = oldValues[0];
	oldValues[0] = Robot::chassis->GetRightSpeed();
	return (oldValues[3] + oldValues[2] + oldValues[1] + oldValues[0]) / 4;
}
double Chassis::GetDistanceUltrasonic( void )
{
	double distanceRange;
#if 0 // SmartDashboard::
	m_minRange = SmartDashboard::GetNumber("Chassis Min Range");
	m_maxRange = SmartDashboard::GetNumber("Chassis Max Range");
#else // SmartDashboard::
	m_minRange = 48.0;
	m_maxRange = 54.0;
#endif // SmartDashboard::
	distanceRange = ultrasonicDrive->GetRangeInches();
	if (distanceRange > m_minRange && distanceRange < m_maxRange)
		lEDRelay->Set(Relay::kForward);
	else 
		lEDRelay->Set(Relay::kOff);
	return distanceRange;
}
void Chassis::UpdateDistance( void )
{
#if 0 // SmartDashboard::
	double oldValues[6];
	oldValues[0] = SmartDashboard::GetNumber("Distance0");
	oldValues[1] = SmartDashboard::GetNumber("Distance1");
	oldValues[2] = SmartDashboard::GetNumber("Distance2");
	oldValues[3] = SmartDashboard::GetNumber("Distance3");
	oldValues[4] = SmartDashboard::GetNumber("Distance4");
	SmartDashboard::PutNumber("Distance0", SmartDashboard::GetNumber("Distance Range"));
	SmartDashboard::PutNumber("Distance1", oldValues[0]);
	SmartDashboard::PutNumber("Distance2", oldValues[1]);
	SmartDashboard::PutNumber("Distance3", oldValues[2]);
	SmartDashboard::PutNumber("Distance4", oldValues[3]);
	SmartDashboard::PutNumber("Distance5", oldValues[4]);
#endif // SmartDashboard::
}
void Chassis::UpdateAccelerometer( void )
{
#if 0 // SmartDashboard::
	//SmartDashboard::PutNumber("AccelX", accel->GetAcceleration(ADXL345_I2C::kAxis_X));
	//SmartDashboard::PutNumber("AccelY", accel->GetAcceleration(ADXL345_I2C::kAxis_Y));
	//SmartDashboard::PutNumber("AccelZ", accel->GetAcceleration(ADXL345_I2C::kAxis_Z));
#endif // SmartDashboard::
}
