// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "Elevator.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Elevator::Elevator() : frc::Subsystem("Elevator") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motor7 = RobotMap::elevatorMotor7;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    motor7->SetInverted(false);			// Sets the Talon invertion to false

    // Set the control mode and target;
    motor7->Set(ControlMode::Position, 0.0);

    // Set to brake mode (in comparison to coast)
    motor7->SetNeutralMode(NeutralMode::Brake);

}

void Elevator::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        //SetDefaultCommand(new Elevate()); // TODO: Put this back in once debugged

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Elevator::Periodic() {
    // Put code here to be run every loop

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Elevator::ElevatePIDInit(double inches) {

	double m_target = inches / (4.0 * M_PI / COUNTS_PER_ROTATION);
	// Initialize encoders to start at zero
	motor7->SetSelectedSensorPosition(0, pidIndex, timeout);

	// Set closed loop error
	motor7->ConfigAllowableClosedloopError(0, 10, timeout);

	// Set power and timeout
	motor7->ConfigPeakOutputForward(0.25, timeout);
	motor7->ConfigPeakOutputReverse(-0.25, timeout);

	// Set proportional
	motor7->Config_kP(0, 0.25/COUNTS_PER_ROTATION, timeout);

	// Set the mode and target
	motor7->Set(ControlMode::Position, m_target);

	motor7->SetSafetyEnabled(false);
}

void Elevator::ElevatePIDExecute() {
	// Nothing here because this will be done in the talon
}

bool Elevator::ElevatePIDatSetPoint() {
	bool pidFinished = false;
	int closedLoopError;

	// Detect if closed loop error has been updated
	closedLoopError = motor7->GetClosedLoopError(0);

	// Check if it is within tolerance
	if (abs(closedLoopError) <= 0.0) { // TODO: Change this to get the tolerance
		pidFinished = true;
	}

	return pidFinished;
}

void Elevator::ElevatePIDStop() {
	// Set the driving mode and target
	motor7->Set(ControlMode::Position, 0.0);

	motor7->SetSafetyEnabled(false);


}
