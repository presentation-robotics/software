// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "Elevator.h"
#include "../RobotMap.h"
#include "../Commands/ElevatorRun.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Elevator::Elevator() : frc::Subsystem("Elevator") {
#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motorL7 = RobotMap::elevatorMotorL7;
    motorR8 = RobotMap::elevatorMotorR8;
    hallLimit = RobotMap::elevatorHallLimit;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    std::printf("2135: Motor L7 ID %d ver %d.%d\n", motorL7->GetDeviceID(), motorL7->GetFirmwareVersion()/256, motorL7->GetFirmwareVersion()%256);
    std::printf("2135: Motor R8 ID %d ver %d.%d\n", motorR8->GetDeviceID(), motorR8->GetFirmwareVersion()/256, motorR8->GetFirmwareVersion()%256);

    RobotConfig* config = RobotConfig::GetInstance();
    config->GetValueAsDouble("E_MotorSpeed", m_elevatorSpeed, 1.0);

    motorL7->SetInverted(false);			// Sets the Talon inversion to false
    motorR8->SetInverted(false);			// Sets the Talon inversion to false
   // Initialize encoders to start at zero
    motorL7->SetSelectedSensorPosition(0, pidIndex, timeout);

    // Set the control mode and target;
    motorL7->Set(ControlMode::PercentOutput, 0.0);
    motorR8->Set(ControlMode::Follower, 7);

    // Set to brake mode (in comparison to coast)
    motorL7->SetNeutralMode(NeutralMode::Brake);
    motorR8->SetNeutralMode(NeutralMode::Brake);

    motorL7->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, 0, timeout);
    motorL7->SetSensorPhase(false);

	// Set power and timeout
	motorL7->ConfigPeakOutputForward(0.1, timeout);
	motorL7->ConfigPeakOutputReverse(-0.1, timeout); //HOLD (256/-256)

    // Set proportional
    motorL7->Config_kP(0, 5120/COUNTS_PER_ROTATION, timeout);

    // Set closed loop error
    motorL7->ConfigAllowableClosedloopError(0, 10, timeout);
#endif

    // Initialize variables
    m_targetInches = 0;
    m_calibrated = false;
}

void Elevator::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
#ifndef ROBORIO_STANDALONE
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new ElevatorRun(0));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
#endif
}

void Elevator::Periodic() {
    // Put code here to be run every loop
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

int Elevator::InchesToCounts(double inches) {
	double counts = (inches / m_circumInches) * COUNTS_PER_ROTATION;
	return counts;
}

double Elevator::CountsToInches(int counts) {
	double inches = (counts / COUNTS_PER_ROTATION) * m_circumInches;
	return inches;
}

void Elevator::SetMotorSpeed(int speed)
{
	double output = 0.0; 		//Default: off

	switch (speed)
	{
	default:
	case ELEVATOR_STOP:
		output = 0.0;
		break;
	case ELEVATOR_UP:
		output = m_elevatorSpeed;
		break;
	case ELEVATOR_DOWN:
		output = -m_elevatorSpeed;
		break;
	}

#ifndef ROBORIO_STANDALONE
	motorL7->Set(ControlMode::PercentOutput, output);
	motorR8->Set(ControlMode::PercentOutput, output);
#endif
}

void Elevator::ElevatePIDInit(double inches) {

	double currentInches;
	double counts;
	m_targetInches = inches;

	// Constraint input request to a valid and safe range
	if (inches < 0.0) {
		m_targetInches = 0.0;
	}
	if (inches > 50.0) {
		m_targetInches = 50.0;
	}
	counts = InchesToCounts(m_targetInches);

#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)

	// Get current position and set the mode and target
	currentInches = motorL7->GetSelectedSensorPosition(pidIndex) / COUNTS_PER_ROTATION * m_circumInches;
	motorL7->Set(ControlMode::Position, counts);

#endif

	std::printf("2135: Elevate Init inches %f -> %f [%f]\n", currentInches, m_targetInches, inches);
}

void Elevator::ElevatePIDExecute() {
	//TEST: std::printf("2135: Elevate periodic\n");
	// Nothing here because this will be done in the talon
}

bool Elevator::ElevatePIDatSetPoint() {
	bool pidFinished = false;
	int encoderCounts = 0;
	double motorOutput = 0.0;
	int closedLoopError = 0;

#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
	encoderCounts = motorL7->GetSelectedSensorPosition(0);
	motorOutput = motorL7->GetMotorOutputPercent();
	closedLoopError = motorL7->GetClosedLoopError(0);
#endif

	// Detect if closed loop error has been updated

	// Check if it is within tolerance
/*	if (abs(motorOutput) >= 0.4) { // TODO: Change this to get the tolerance
		m_pidStarted = true;*/

	//EncCount = Encoder Counts, CLE = Closed Loop Error, M_Output = Motor Output
	std::printf("2135: EncCount %d, CLE %d, M_Output %f\n", encoderCounts, closedLoopError, motorOutput);

	//Checks to see if the error is in an acceptable number of inches.
	targetCounts = InchesToCounts(m_targetInches);
	errorInInches = (abs(encoderCounts - targetCounts));
	if (errorInInches < 2) {
		pidFinished = true;
		std::printf("2135: Finished\n");
	}
	else {
		pidFinished = false;
	}

/*
	if (m_pidStarted == true && abs(motorOutput) <= 0.1) {
		pidFinished = true;
		std::printf("2135: Finished\n");
	}
*/

//Stops command.
	if (m_pidStarted == true && closedLoopError <= 20) {
		pidFinished = true;
		std::printf("2135: Finished\n");
	}

	if (hallLimit->Get() == false) {
		std::printf("2135: Hall Effect Detected\n");
//		pidFinished = true;
	}

	return pidFinished;
}

void Elevator::ElevatePIDStop() {
	std::printf("2135: Elevate Stop\n");
}

void Elevator::Calibrate() {
#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
	// Hall sensor is false when near magnet
	if (!hallLimit->Get()) {
		std::printf("2135: Hall Limit Detected\n");
	    motorL7->SetSelectedSensorPosition(0, pidIndex, timeout);
		motorL7->Set(ControlMode::Position, 0.0);
		m_calibrated = true;
	}
	else {
		motorL7->Set(ControlMode::PercentOutput, -0.1);
	}
#endif
}

bool Elevator::CalibrateIsFinished() {

	// Hall sensor is false when near magnet
	return m_calibrated;
}

void Elevator::CalibrateStop() {
//Done in Calibrate.
}
