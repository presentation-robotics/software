// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "Elevator.h"
#include "../RobotMap.h"
#include "../Commands/ElevatorRun.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Elevator::Elevator() : frc::Subsystem("Elevator") {
#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motorL7 = RobotMap::elevatorMotorL7;
    motorR8 = RobotMap::elevatorMotorR8;
    hallLimit = RobotMap::elevatorHallLimit;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Display Talon SRX firmware versions
    std::printf("2135: Motor L7 ID %d ver %d.%d\n", motorL7->GetDeviceID(), motorL7->GetFirmwareVersion()/256, motorL7->GetFirmwareVersion()%256);
    std::printf("2135: Motor R8 ID %d ver %d.%d\n", motorR8->GetDeviceID(), motorR8->GetFirmwareVersion()/256, motorR8->GetFirmwareVersion()%256);

    // Get any config file settings
    RobotConfig* config = RobotConfig::GetInstance();
    config->GetValueAsDouble("E_MotorSpeed", m_elevatorSpeed, 0.4);
    config->GetValueAsDouble("E_CalibSpeed", m_calibrationSpeed, 0.2);
    config->GetValueAsDouble("E_MaxHeight", m_elevatorMaxHeight, 35.0);
    config->GetValueAsDouble("E_MinHeight", m_elevatorMinHeight, 0.0);

    // Initialize Talon SRX motor controller direction and encoder sensor slot
    motorL7->SetInverted(false);			// Sets the Talon inversion to false
    motorR8->SetInverted(false);			// Sets the Talon inversion to false

    // Set the control mode and target to disable any movement
    motorL7->Set(ControlMode::PercentOutput, 0.0);
    motorR8->Set(ControlMode::Follower, 7);

    // Set to brake mode (in comparison to coast)
    motorL7->SetNeutralMode(NeutralMode::Brake);
    motorR8->SetNeutralMode(NeutralMode::Brake);

    // Set encoder as a CTRE magnetic in relative mode with sensor in phase with output
    motorL7->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, m_pidIndex, m_timeout);
    motorL7->SetSensorPhase(true);
    motorL7->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);

	// Set maximum power and timeout
	motorL7->ConfigPeakOutputForward(m_elevatorSpeed, m_timeout);
	motorL7->ConfigPeakOutputReverse(-m_elevatorSpeed, m_timeout);
	motorL7->ConfigClosedloopRamp(0.5, m_timeout);

	// Set maximum current draw allowed
	motorL7->ConfigPeakCurrentLimit(10.0, m_timeout);
	motorR8->ConfigPeakCurrentLimit(10.0, m_timeout);
	motorL7->EnableCurrentLimit(false);
	motorR8->EnableCurrentLimit(false);

    // Set proportional
    motorL7->Config_kP(m_slotIndex, (1023)/COUNTS_PER_ROTATION, m_timeout);
//    motorL7->Config_kD(m_slotIndex, 10 * (0.5 * 1023)/COUNTS_PER_ROTATION, m_timeout);

    motorL7->ConfigForwardSoftLimitThreshold(m_elevatorMaxHeight, m_timeout);
    motorL7->ConfigReverseSoftLimitThreshold(m_elevatorMinHeight, m_timeout);
//    motorL7->ConfigForwardSoftLimitEnable(true, m_timeout);
//    motorL7->ConfigReverseSoftLimitEnable(true, m_timeout);

    // Set allowable closed loop error
    motorL7->ConfigAllowableClosedloopError(m_slotIndex, 10, m_timeout);
#endif

    // Initialize variables
    m_curInches = 0.0;
    m_targetInches = 0.0;
    m_targetCounts = 0.0;
    m_calibrated = false;
    m_calibrationState = 0;
}

void Elevator::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
#ifndef ROBORIO_STANDALONE
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new ElevatorRun(0));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
#endif
}

void Elevator::Periodic() {
    // Put code here to be run every loop
	SmartDashboard::PutNumber("Elevator Height", CountsToInches(motorL7->GetSelectedSensorPosition(m_pidIndex)));
	SmartDashboard::PutNumber("Gripper Height", 2*CountsToInches(motorL7->GetSelectedSensorPosition(m_pidIndex)));
	SmartDashboard::PutBoolean("Hall Sensor", HallSensorIsTriggered());
	SmartDashboard::PutBoolean("Elevator Calibrated", m_calibrated);
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

double Elevator::InchesToCounts(double inches) {
	double counts;

	counts = (inches / m_circumInches) * COUNTS_PER_ROTATION;
	return counts;
}

double Elevator::CountsToInches(int counts) {
	double inches;

	inches = ((double) counts / COUNTS_PER_ROTATION) * m_circumInches;
	return inches;
}

double Elevator::GetCurrentInches () {
	double curCounts;

	curCounts = motorL7->GetSelectedSensorPosition(m_pidIndex);
	m_curInches = CountsToInches(curCounts);
	return m_curInches;
}

bool Elevator::HallSensorIsTriggered() {
	// Hall sensor is false when magnet is nearby
#ifndef ROBORIO_STANDALONE
	return !hallLimit->Get();
#endif
}

void Elevator::Bump(bool direction) {
	double curHeight;
	double bump;

	curHeight = GetCurrentInches();
	RobotConfig* config = RobotConfig::GetInstance();
	config->GetValueAsDouble("EL_Bump", bump, 1.0);

	if (direction)
		MoveToPosition(curHeight + bump);
	else
		MoveToPosition(curHeight - bump);
}

void Elevator::MoveToPosition(double inches) {

	double curInches = 0.0;
	int curCounts = 0;

	// Save the requested target height inches
	m_targetInches = inches;
	if (m_calibrated == true) {

		// Constrain input request to a valid and safe range between full down and max height
		if (inches < 0.0) {
			m_targetInches = 0.0;
		}
		if (inches > 50.0) { //TODO Determine upwards limit
			m_targetInches = 50.0;
		}

		m_targetCounts = InchesToCounts(m_targetInches);

#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
	// Get current position in inches and set position mode and target counts
	curCounts = motorL7->GetSelectedSensorPosition(m_pidIndex);
	curInches = CountsToInches(curCounts);
	m_curInches = curInches;
	motorL7->Set(ControlMode::Position, m_targetCounts);
#endif

		std::printf("2135: Elevator Init inches %f -> %f [%f] counts %d -> %f\n", curInches, m_targetInches, inches, curCounts, m_targetCounts);
	}
	else {
		printf("2135: Elevator is not calibrated\n");
#ifndef ROBORIO_STANDALONE
		motorL7->Set(ControlMode::PercentOutput, 0.0);
#endif
	}
}

bool Elevator::MoveToPositionIsFinished() {
	bool pidFinished = false;
	int curCounts = 0;
	int closedLoopError = 0;
	double motorOutput = 0.0;
	double errorInInches = 0;

#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
	curCounts = motorL7->GetSelectedSensorPosition(m_pidIndex);
	closedLoopError = motorL7->GetClosedLoopError(m_pidIndex);
	motorOutput = motorL7->GetMotorOutputPercent();
#endif

	// EncCount = Encoder Counts, CLE = Closed Loop Error, M_Output = Motor Output
	std::printf("2135: EncCount %d, CLE %d, M_Output %f\n", curCounts, closedLoopError, motorOutput);

	// Check to see if the error is in an acceptable number of inches.
	errorInInches = CountsToInches(m_targetCounts - (double)curCounts);
	if (fabs(errorInInches) < 2.0) {
		pidFinished = true;
		std::printf("2135: Finished\n");
	}
	else {
		pidFinished = false;
	}

	return pidFinished;
}

void Elevator::MoveToPositionStop() {
#ifndef ROBORIO_STANDALONE
	motorL7->Set(ControlMode::PercentOutput, 0.0);
	std::printf("2135: Safety timer has timed out\n");
#endif
}

void Elevator::CalibrationInit() {
	m_calibrated = false;
	m_calibrationState = CALIB_START;
#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
	motorL7->Set(ControlMode::PercentOutput, 0.0);
#endif
}

void Elevator::CalibrationExecute() {

	// Calibration state machine

#if !defined (ROBORIO_STANDALONE) || defined (ROBOTBENCHTOPTEST)
	static int lastCalibState = -1;

	switch (m_calibrationState) {
	case CALIB_START:
		// Hall sensor is false when near magnet
		if (HallSensorIsTriggered()) {
			// Near magnet, reset encoder and move up a little using encoder
			std::printf("2135: Calibration - move UP first\n");
			motorL7->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);
			motorL7->Set(ControlMode::PercentOutput, m_calibrationSpeed);
			m_calibrationState = CALIB_MOVE_UP;
		}
		else {
			std::printf("2135: Calibration - move DOWN first\n");
			// Not near magnet, start moving down
			m_calibrationState = CALIB_START_DOWN;
		}
		break;
	case CALIB_MOVE_UP:
		// Check to see if moved up 3 rotations
		printf("2135: Encoder Counts %d\n", motorL7->GetSelectedSensorPosition(m_pidIndex));
		if (abs(motorL7->GetSelectedSensorPosition(m_pidIndex)) > (COUNTS_PER_ROTATION)) {
			std::printf("2135: Calibration - done moving up\n");
			motorL7->Set(ControlMode::PercentOutput, 0.0);
			m_calibrationState = CALIB_START_DOWN;
		}
		break;
	case CALIB_START_DOWN:
		std::printf("2135: Calibration - start moving down\n");
		motorL7->Set(ControlMode::PercentOutput, -m_calibrationSpeed);
		m_calibrationState = CALIB_MOVE_DOWN;
		break;
	case CALIB_MOVE_DOWN:
		// Hall sensor is false when near magnet
		if (HallSensorIsTriggered()) {
			// Near magnet, end of calibration
			std::printf("2135: Calibration - done moving down - Hall sensor found\n");
			motorL7->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);
			motorL7->Set(ControlMode::PercentOutput, 0.0);
			m_calibrationState = CALIB_DONE;
		}
		break;
	case CALIB_DONE:
		motorL7->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);
		motorL7->Set(ControlMode::Position, 0.0);
		m_calibrated = true;
		break;
	}

	// If calibration state changes, print new value
	if (m_calibrationState != lastCalibState) {
		std::printf("2135: Elevator State: %d\n", m_calibrationState);
		lastCalibState = m_calibrationState;
	}
#endif
}

bool Elevator::CalibrationIsFinished() {
	// Hall sensor is false when near magnet
	return m_calibrated;
}

void Elevator::CalibrationOverride() {
	m_calibrationState = CALIB_DONE;
	CalibrationExecute();
}
