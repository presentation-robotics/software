// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "Elevator.h"
#include "../RobotMap.h"
#include "../Commands/ElevatorRun.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Elevator::Elevator() : frc::Subsystem("Elevator") {
#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    motorL11 = RobotMap::elevatorMotorL11;
    motorR12 = RobotMap::elevatorMotorR12;
    hallSensorTop = RobotMap::elevatorHallSensorTop;
    hallSensorBottom = RobotMap::elevatorHallSensorBottom;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    motorL11->SetInverted(false);			// Sets the Talon invertion to false
    motorR12->SetInverted(false);			// Sets the Talon invertion to false
   // Initialize encoders to start at zero
    motorL11->SetSelectedSensorPosition(0, pidIndex, timeout);

    // Set the control mode and target;
    motorL11->Set(ControlMode::Position, 0.0);
    motorR12->Set(ControlMode::Follower, 11);

    // Set to brake mode (in comparison to coast)
    motorL11->SetNeutralMode(NeutralMode::Brake);
    motorR12->SetNeutralMode(NeutralMode::Brake);

    std::printf("2135: Motor L11 ID %d ver %d.%d\n", motorL11->GetDeviceID(), motorL11->GetFirmwareVersion()/256, motorL11->GetFirmwareVersion()%256);
    std::printf("2135: Motor R12 ID %d ver %d.%d\n", motorR12->GetDeviceID(), motorR12->GetFirmwareVersion()/256, motorR12->GetFirmwareVersion()%256);

    motorL11->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, 0, timeout);
    motorL11->SetSensorPhase(false);

	// Set power and timeout
	motorL11->ConfigPeakOutputForward(0.1, timeout);
	motorL11->ConfigPeakOutputReverse(-0.1, timeout); //HOLD (256/-256)

    // Set proportional
    motorL11->Config_kP(0, 5120/COUNTS_PER_ROTATION, timeout);

    // Set closed loop error
    motorL11->ConfigAllowableClosedloopError(0, 10, timeout);

    // Initialize hall sensors
    hallSensorTop = RobotMap::elevatorHallSensorTop;
    hallSensorBottom = RobotMap::elevatorHallSensorBottom;
#endif

    // Initialize variables
    m_pidStarted = false;


    RobotConfig* config = RobotConfig::GetInstance();
    config->GetValueAsDouble("E_MotorSpeed", m_gripperSpeed, 1.0);
}

void Elevator::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
//#ifdef ROBOTNOTSTANDALONE
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
//#endif
}

void Elevator::Periodic() {
    // Put code here to be run every loop
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Elevator::SetMotorSpeed(int speed)
{
#ifdef ROBOTNOTSTANDALONE

	double output = 0.0; 		//Default: off

	switch (speed)
	{
	default:
	case ELEVATOR_STOP:
		output = 0.0;
		break;
	case ELEVATOR_UP:
		output = m_gripperSpeed;
		break;
	case ELEVATOR_DOWN:
		output = -m_gripperSpeed;
		break;
	}

	motorL11->Set(ControlMode::PercentOutput, output);
	motorR12->Set(ControlMode::PercentOutput, output);

#endif
}

void Elevator::ElevatePIDInit(double inches) {
#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)

	std::printf("2135: PIDInit Current Encoder Counts: %5d\n", motorL11->GetSelectedSensorPosition(pidIndex));

	m_inches = inches;

	double counts = (inches / circumInches) * COUNTS_PER_ROTATION;

	std::printf("2135: Elevate Init\n");

	if (inches < 0) {
	}
	else {
	// Set the mode and target
	motorL11->Set(ControlMode::Position, counts);
	}

	m_pidStarted = false;

#endif
}

void Elevator::ElevatePIDExecute() {
	//TEST: std::printf("2135: Elevate periodic\n");
	// Nothing here because this will be done in the talon
}

bool Elevator::ElevatePIDatSetPoint() {
	bool pidFinished = false;

#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)

	int closedLoopError = 0;	// initialized for ROBOTNOTSTANDALONE mode

	// Detect if closed loop error has been updated
	closedLoopError = motorL11->GetClosedLoopError(0);
	std::printf("2135: Closed Loop error %d\n", closedLoopError);
	std::printf("2135: Encoder count %d\n", motorL11->GetSelectedSensorPosition(0));

	// Check if it is within tolerance
	double motorOutput = motorL11->GetMotorOutputPercent();
/*	if (abs(motorOutput) >= 0.4) { // TODO: Change this to get the tolerance
		m_pidStarted = true;*/
	if (!m_pidStarted && (abs(closedLoopError) > COUNTS_PER_ROTATION))
	{
		m_pidStarted = true; //HOLD OUT WHEN READY
		std::printf("2135: PID Started\n");
	}

	std::printf("2135: Motor Output: %f\n", motorOutput);
/*
	if (m_pidStarted == true && abs(motorOutput) <= 0.1) {
		pidFinished = true;
		std::printf("2135: Finished\n");
	}
*/

//Stops command.
	if (m_pidStarted == true && closedLoopError <= 20) {
		pidFinished = true;
		std::printf("2135: Finished\n");
	}


	if (hallSensorBottom->Get() == false || hallSensorTop->Get() == false) {
		std::printf("2135: Hall Effect Detected\n");
//		pidFinished = true;
	}

#endif
	return pidFinished;
}

void Elevator::ElevatePIDStop() {
#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
	std::printf("2135: Elevate STOP\n");

	// Set the driving mode and target
//To keep PID running, this is commented out.
//	motorL11->Set(ControlMode::PercentOutput, 0.0);

//	motorL11->SetSelectedSensorPosition(0, pidIndex, timeout);
//	motorL11->SetSelectedSensorPosition(0, pidIndex, timeout);
#endif

}

void Elevator::Calibrate() {
#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
	if (hallSensorBottom->Get() == false) {
		std::printf("2135: Hall Effect Bottom Detected\n");
		motorL11->Set(ControlMode::PercentOutput, 0.0);
	    motorL11->SetSelectedSensorPosition(0, pidIndex, timeout);
	}
	else {
		motorL11->Set(ControlMode::PercentOutput, -0.1);
	}

#endif
}

bool Elevator::CalibrateIsFinished() {

	bool m_isFinished;
	m_isFinished = false;

#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
	if (hallSensorBottom->Get() == false) {
		m_isFinished = true;
	}
#endif

	return m_isFinished;
}

void Elevator::CalibrateStop() {
#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
	motorL11->StopMotor();
#endif
}

void Elevator::MoveToTopLimit() {
#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
	if (hallSensorTop->Get() == false) {
		std::printf("2135: Hall Effect Top Detected\n");
		motorL11->Set(ControlMode::PercentOutput, 0.0);
	}
	else {
		motorL11->Set(ControlMode::PercentOutput, 0.1);
	}
#endif
}

bool Elevator::MoveToTopLimitIsFinished() {

	bool m_isFinished;
	m_isFinished = false;

#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
	if (hallSensorTop->Get() == false) {
		m_isFinished = true;
	}
#endif

	return m_isFinished;
}

void Elevator::MoveToTopLimitStop() {
#if defined (ROBOTNOTSTANDALONE) || defined (ROBOTBENCHTOPTEST)
	motorL11->StopMotor();
#endif
}
