// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "AutoPos1.h"
#include "AutoPosANYMove.h"
#include "AutoPos1Switch.h"
#include "AutoPos1Scale.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutoPos1::AutoPos1(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	std::printf("2135: Auto Pos 1 Constructor\n");
}// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutoPos1::Initialize() {
	std::printf("2135: Auto Pos 1 - Init\n");

}

// Called repeatedly when this Command is scheduled to run
void AutoPos1::Execute() {
	// Wait for gameData before scheduling next steps
}

// Make this return true when this Command no longer needs to run execute()
bool AutoPos1::IsFinished() {
	bool	isFinished = false;

	// Check if gameData has been sent
	std::string alliSwitch;
	std::string scale;
	frc::Command	*cmd;

	alliSwitch = SmartDashboard::GetString(ROBOT_FMSALLISWITCH, ROBOT_FMS_UNINIT);
	// If not the uninitialized string, then new data received
    if(alliSwitch.compare(ROBOT_FMS_UNINIT) && !(alliSwitch.empty()))
    	{
    	scale = SmartDashboard::GetString(ROBOT_FMSSCALE, ROBOT_FMS_UNINIT);
    	std::printf("2135: Auto Pos 1 - AlliSwitch: %s Scale %s\n",alliSwitch.c_str(), scale.c_str());

       		if (alliSwitch == ROBOT_FMS_RIGHT) {
        		if (scale == ROBOT_FMS_RIGHT) {
        			cmd = new(AutoPosANYMove);
        			cmd->Start();
        		}
        		else {
        			cmd = new(AutoPos1Scale);
        			cmd->Start();
        		}
        	}
        	else {
        		if (scale == ROBOT_FMS_RIGHT) {
        			cmd = new(AutoPos1Switch);
        			cmd->Start();
        		}
        		else {
        			cmd = new(AutoPos1Scale);
        			cmd->Start();
        			//Put in logic to choose from SmartDashboard (switch or scale)
        		}
        }
    	// Build group command for Pos 1 decisions here!

    	// If switch == right
    	//		If scale == right
    	//			drive forward to take the autonomous line
    	// *** This should be enough to start a group command even if the calling command finishes ***
    	// cmd = new (AutoPosANYMove);
    	// cmd->Start();
    	//		Else	/* scale is left */
    	//			attack the scale
    	// Else		/* switch is left */
    	//		If scale == right
    	//			attack the switch
    	//		Else	/* scale is left */
    	//			If dashboard setting says TAKE THE SCALE
    	//				attack the scale
    	//			Else
    	//				attack the switch

    	// Let this command finish
    	isFinished = true;
    }
    return isFinished;
}

// Called once after isFinished returns true
void AutoPos1::End() {
	std::printf("2135: Auto Pos 1 - End\n");
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutoPos1::Interrupted() {
	std::printf("2135: Auto Pos 1 - Interrupted\n");
}
