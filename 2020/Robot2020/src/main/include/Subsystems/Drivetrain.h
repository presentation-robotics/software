// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#pragma once

#include <frc/commands/Subsystem.h>
#include <frc/Joystick.h>
#include <frc/PIDController.h>
#include <frc/PIDOutput.h>
#include <frc/PIDSource.h>
#include <frc/controller/PIDController.h>
#include <frc/controller/SimpleMotorFeedforward.h>
#include <frc/kinematics/DifferentialDriveKinematics.h>
#include <frc/kinematics/DifferentialDriveOdometry.h>

#include <ctre/phoenix/sensors/PigeonIMU.h>

#include "frc2135/TalonUtils.h"
#include "frc2135/RobotConfig.h"
#include "frc2135/PIDOutputDriveVision.h"
#include "frc2135/PIDSourceDriveVision.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "ctre/Phoenix.h"
#include "frc/DoubleSolenoid.h"
#include "frc/drive/DifferentialDrive.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

/**
 *
 *
 * @author ExampleAuthor
 */
class Drivetrain: public frc::Subsystem
{

private:
    // It's desirable that everything possible is private except
    // for methods that implement subsystem capabilities

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<WPI_TalonFX> motorL1;
	std::shared_ptr<WPI_TalonFX> motorR3;
	std::shared_ptr<frc::DifferentialDrive> diffDrive;
	std::shared_ptr<WPI_TalonFX> motorL2;
	std::shared_ptr<WPI_TalonFX> motorR4;
	std::shared_ptr<frc::DoubleSolenoid> shifter;
	std::shared_ptr<PigeonIMU> pigeonIMU;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    //    Declare constants
    const int       m_driveDebug = 0;           // Debug flag to disable extra logging calls
    const int       m_alignTurnDebug = 0;       // Debug flag to disable extra logging calls
    const int       kPidIndex = 0;              // PID slot index for sensors
    const int       kCANTimeout = 30;           // CAN timeout in msec to wait for response

    // Drivetrain constants
    const double    kWheelDiaInches = 6.0;      // Measured wheel diameter
    const int       kWheelCPR = (1024 * 4);     // CPR is 1024 and multiplied by 4 since quadrature
    const units::foot_t kTrackWidthFeet = 2.125_ft; // Measured track width

    // Derived values
    const double    kWheelCircumInches = kWheelDiaInches * M_PI;
    const double    kWheelCountsPerInch = kWheelCPR / kWheelCircumInches;
    const double    kFeetPerCount = (kWheelCircumInches / 12) / kWheelCPR;

    const int       m_reqPigeonVer = ((20 * 256) + 0);   // Pigeon IMU version is 20.0

    // Declare module variables
    bool            m_talonValidL1;     // Health indicator for drive Talon Left 1
    bool            m_talonValidL2;     // Health indicator for drive Talon Left 2
    bool            m_talonValidR3;     // Health indicator for drive Talon Right 3
    bool            m_talonValidR4;     // Health indicator for drive Talon Right 4
    bool            m_pigeonValid;      // Health indicator for Pigeon IMU

    double          m_driveXScaling;    // Scaling applied to Joystick
    double          m_driveYScaling;    // Scaling applied to Joystick
    double          m_driveSpin;        // Spin turn power  setting

    bool            m_lowGear;          // Low Gear or High Gear
    bool            m_brakeMode;        // Brake or Coast Mode for Talons

    frc::Timer      m_safetyTimer;      // Safety timer for use during autonomous modes
    double          m_safetyTimeout;    // Time in seconds for safety timer
    bool            m_isMovingAuto;     // Indicates an auton movement is active

    double          m_distTargetInches; // Drive to Position target inches value
    double          m_distTargetCounts; // Drive to Position target counts value
    double          m_distTolInches;    // Tolerated error for MM PID loop

    double          m_turnAngle = 0.0;  // Desired turn angle from present course
    double          m_turnTolDeg;       // DriveTurn tolerance in degrees
    double          m_turnKp;           // Proportional value for PID for DriveTurn function
    double          m_visionTurnKp;     // Proportional value for PID for Drive Turn with Vision-Assist
    double          m_turnMaxOut;       // Max motor output value for PID for DriveTurn function
	double          m_alignTurnTolerance; // Minimum align turn error to finish aligning

    double          m_peakOut;          // Drivetrain maximum speed during movement
    int             m_velocity;         // Drivetrain motion velocity
    int             m_acceleration;     // Drivetrain motion acceleration
    int             m_sCurveStrength;   // Drivetrain motion S curve smoothing strength
    double          m_pidKf;            // Drivetrain PID force constant
    double          m_pidKp;            // Drivetrain PID proportional constant
    double          m_pidKi;            // Drivetrain PID integral constant
    double          m_pidKd;            // Drivetrain PID derivative constant
    double          m_arbFeedForward;   // Drivetrain Motion Magic Arbitrary Feed Forward

    double         m_vcMaxSpeed;
    double         m_vcMaxAngSpeed;
    double         m_vcpidKp;
    double         m_vcpidKi;
    double         m_vcpidKd;

    double         m_openLoopRampRate;
    double         m_closedLoopRampRate;

    frc::SimpleMotorFeedforward<units::feet> m_feedforward {0.899_V, 1.411_V / 1_fps, 0.21_V / 1_fps_sq}; // Do another drive characterization
    frc2::PIDController *m_leftPIDController;
    frc2::PIDController *m_rightPIDController;

    frc::DifferentialDriveKinematics *m_kinematics;
    frc::DifferentialDriveOdometry *m_odometry;

    bool            m_throttleZeroed;   // Throttle joystick zeroed check for safety

    double          m_alignTurnKp;
    double          m_alignTurnError;

    typedef enum driveMode_e
    { // Driving Algorithms
        DRIVEMODE_FIRST      = 0,
        DRIVEMODE_ARCADE     = DRIVEMODE_FIRST,
        DRIVEMODE_CURVATURE  = 1,
        DRIVEMODE_VELCONTROL = 2,
    //    DRIVEMODE_CUBIC      = 3,
        DRIVEMODE_LAST
    } driveMode_e;

    int             m_curDriveMode;         // Current driving mode, arcade by default

    // PIDOutputDriveTurn *driveTurnPIDOutput; // Drive turn to angle with gyro
    // PIDSourceDriveTurn *driveTurnPIDSource; // Drive turn PID source loop
    // frc::PIDController *driveTurnPIDLoop;   // Drive turn PID control

    PIDOutputDriveVision *driveVisionPIDOutput; // Drive with Vision to angle using gyro - initialize output
    PIDSourceDriveVision *driveVisionPIDSource; // Drive with Vision PID source loop
    frc2::PIDController  *driveVisionPIDLoop;   // Drive with Vision PID controller loop

    void ResetSensors();

    // Brake or Coast Mode
    void MoveSetBrakeMode(bool m_brakeMode);

    // Conversion Functions
    double InchesToCounts(double inches);
    double CountsToInches(int counts);

    double GetEncoderPosition(int motorID);

    // Pigeon IMU
    bool PigeonIMUInitialize();
    void PigeonIMUFaultDump(void);
    double GetIMUHeading();
    frc::Rotation2d GetAngle();

public:
    Drivetrain();
    void InitDefaultCommand() override;
    void Periodic() override;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    void Initialize(void);
    void FaultDump(void);

    void MoveWithJoysticks(std::shared_ptr<frc::Joystick>);
    void ToggleDriveMode();

    // Velocity Control Loop
    void VelocityCLDrive(const frc::DifferentialDriveWheelSpeeds& speeds);
    void UpdateOdometry();
    double GetDistanceFeet(std::shared_ptr<WPI_TalonFX>);
    double GetSpeedFPS(std::shared_ptr<WPI_TalonFX>);

    void MoveSpin(bool spinRight);
    void MoveStop();

    // Shifting Gears
    void MoveShiftGears(bool lowGear);

    void MoveDriveStraight(double output);

    // Driving to a distance using Motion Magic
    void MoveDriveDistanceMMInit(double distance);
    void MoveDriveDistanceMMExecute();
    bool MoveDriveDistanceMMIsFinished();
    void MoveDriveDistanceMMEnd();

    // Aligning with Target Using Vision Processing
    void MoveAlignTurnInit();
    void MoveAlignTurnExecute(std::shared_ptr<frc::Joystick>);
    bool MoveAlignTurnIsFinished();

    // Aligning with Target Using Vision Processing with (deprecated) PID Controller
    void MoveAlignTurnPIDInit();
    void MoveAlignTurnPIDExecute(double targetHorz);
    bool MoveAlignTurnPIDISFinished();
    void MoveAlignTurnPIDStop();

    void BumpRampRate(bool bumpUp);
};

