// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include <frc/RobotController.h>
#include <frc/RobotState.h>
#include <frc/smartdashboard/SmartDashboard.h>

#include <frc2135/TalonSRXUtils.h>

#include "Subsystems/Drivetrain.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/DriveTeleop.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {

    std::printf("2135: DT Drivetrain Constructor\n");

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
motorL1.reset(new WPI_TalonSRX(1));


motorR3.reset(new WPI_TalonSRX(3));


diffDrive.reset(new frc::DifferentialDrive(*motorL1, *motorR3));
AddChild("DiffDrive", diffDrive);
diffDrive->SetSafetyEnabled(true);
diffDrive->SetExpiration(0.25);
diffDrive->SetMaxOutput(1.0);

motorL2.reset(new WPI_TalonSRX(2));


motorR4.reset(new WPI_TalonSRX(4));


shifter.reset(new frc::DoubleSolenoid(0, 0, 1));
AddChild("Shifter", shifter);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	pigeonIMU.reset(new PigeonIMU(motorL2.get()));

    // Validate Talon SRX controllers, initialize and display firmware versions
    m_talonValidL1 = frc2135::TalonSRXUtils::TalonSRXCheck(motorL1, "DT", "L1");
    m_talonValidL2 = frc2135::TalonSRXUtils::TalonSRXCheck(motorL2, "DT", "L2");
    m_talonValidR3 = frc2135::TalonSRXUtils::TalonSRXCheck(motorR3, "DT", "R3");
    m_talonValidR4 = frc2135::TalonSRXUtils::TalonSRXCheck(motorR4, "DT", "R4");

    // Invert the direction of the motors
    // Set to brake mode (in comparison to coast)
    // Set Voltage Compensation to 12V
    // Set encoder as a CTRE magnetic in relative mode with sensor in phase with output
    if (m_talonValidL1) {
        motorL1->SetInverted(InvertType::InvertMotorOutput);
        motorL1->SetNeutralMode(NeutralMode::Coast);
        motorL1->ConfigVoltageCompSaturation(12.0, m_timeout);
        motorL1->EnableVoltageCompensation(true);
        motorL1->Set(ControlMode::PercentOutput, 0.0);

        motorL1->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, m_pidIndex, m_timeout);
        motorL1->SetSensorPhase(false);
        motorL1->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);

		// Configure Magic Motion settings
		// motorL1->SelectProfileSlot(0, 0);
		// motorL1->ConfigClosedLoopPeakOutput(0, m_peakOut, m_timeout);
        // motorL1->ConfigMotionCruiseVelocity(877, m_timeout);   // 877 for 6.73 fps
        // motorL1->ConfigMotionAcceleration(1000, m_timeout);
		// motorL1->ConfigMotionSCurveStrength(0, m_sCurveStrength);
        // motorL1->Config_kF(0, m_pidKf, m_timeout);         	// 0.5832 for 6.73 fps
        // motorL1->Config_kP(0, m_pidKp, m_timeout);
        // motorL1->Config_kI(0, m_pidKi, m_timeout);
        // motorL1->Config_kD(0, m_pidKd, m_timeout);
    }

    if (m_talonValidL2) {
    	motorL2->SetInverted(InvertType::InvertMotorOutput);
        motorL2->SetNeutralMode(NeutralMode::Coast);
        motorL2->ConfigVoltageCompSaturation(12.0, m_timeout);
        motorL2->EnableVoltageCompensation(true);
        motorL2->Set(ControlMode::PercentOutput, 0.0);
    }

    if (m_talonValidR3) {
        motorR3->SetInverted(InvertType::InvertMotorOutput);
        motorR3->SetNeutralMode(NeutralMode::Coast);
        motorR3->ConfigVoltageCompSaturation(12.0, m_timeout);
        motorR3->EnableVoltageCompensation(true);
        motorR3->Set(ControlMode::PercentOutput, 0.0);

        motorR3->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, m_pidIndex, m_timeout);
        motorR3->SetSensorPhase(false);
        motorR3->SetSelectedSensorPosition(0, m_pidIndex, m_timeout);

		// Configure Magic Motion settings
        // motorR3->SelectProfileSlot(0, 0);
		// motorR3->ConfigClosedLoopPeakOutput(0, m_peakOut, m_timeout);
        // motorR3->ConfigMotionCruiseVelocity(877, m_timeout);   // 877 for 6.73 fps
        // motorR3->ConfigMotionAcceleration(1000, m_timeout);
		// motorR3->ConfigMotionSCurveStrength(0, m_sCurveStrength);
        // motorR3->Config_kF(0, m_pidKf, m_timeout);         	// 0.5832 for 6.73 fps
        // motorR3->Config_kP(0, m_pidKp, m_timeout);
        // motorR3->Config_kI(0, m_pidKi, m_timeout);
        // motorR3->Config_kD(0, m_pidKd, m_timeout);
    }

    if (m_talonValidR4) {
        motorR4->SetInverted(InvertType::InvertMotorOutput);
        motorR4->SetNeutralMode(NeutralMode::Coast);
        motorR4->ConfigVoltageCompSaturation(12.0, m_timeout);
        motorR4->EnableVoltageCompensation(true);
        motorR4->Set(ControlMode::PercentOutput, 0.0);
   }

	m_driveXScaling = 1.0;
	m_driveYScaling = 1.0;

    // Set to low gear (default)
    m_lowGear = true;
    MoveShiftGears(m_lowGear);

	m_curDriveMode = DRIVEMODE_LAST;
	ToggleDriveMode();

    // If either master drive talons are valid, enable safety timer
    diffDrive->SetSafetyEnabled(m_talonValidL1 || m_talonValidR3);

	// Initialize and calibrate Pigeon IMU
	m_pigeonValid = PigeonIMUInitialize();
}

void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveTeleop());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {
    // Put code here to be run every loop
	static int 	i = 0;
    int			encoderLeft = 0;
	int			encoderRight = 0;
 	double  	heading = 0.0;

    if (m_talonValidL1) {
		encoderLeft = motorL1->GetSelectedSensorPosition(m_pidIndex);
	}

	if (m_talonValidR3) {
		encoderRight = -motorR3->GetSelectedSensorPosition(m_pidIndex);
	}

	heading = GetIMUHeading();

	frc::SmartDashboard::PutNumber("DT_Encoder_L", encoderLeft);
	frc::SmartDashboard::PutNumber("DT_Encoder_R", encoderRight);
	frc::SmartDashboard::PutNumber("DT_Heading", heading);

    if (m_driveDebug > 1 || (m_driveDebug > 0 && m_isMovingAuto)) {

		// SLow debug message rate to every 5 * 20ms periods
		if (i++ % 5 == 0) {
			double	outputL1 = 0.0, outputL2 = 0.0, currentL1 = 0.0, currentL2 = 0.0;
			double	outputR3 = 0.0, outputR4 = 0.0, currentR3 = 0.0, currentR4 = 0.0;

			if (m_talonValidL1) {
				outputL1 = motorL1->GetMotorOutputPercent();
				currentL1 = motorL1->GetOutputCurrent();
			}

			if (m_talonValidL2) {
				outputL2 = motorL2->GetMotorOutputPercent();
				currentL2 = motorL2->GetOutputCurrent();
			}

			if (m_talonValidR3) {
				outputR3 = motorR3->GetMotorOutputPercent();
				currentR3 = motorR3->GetOutputCurrent();
			}

			if (m_talonValidR4) {
				outputR4 = motorR4->GetMotorOutputPercent();
				currentR4 = motorR4->GetOutputCurrent();
			}

			double secs = (double)frc::RobotController::GetFPGATime() / 1000000.0;

			std::printf("2135: DT %6.3f deg %4.1f turn %4.1f LR cts %5d %5d out %4.2f %4.2f amps %6.3f %6.3f %6.3f %6.3f\n",
				secs, heading, m_turnAngle, encoderLeft, encoderRight, outputL1, outputR3, currentL1, currentL2, currentR3, currentR4);

			frc::SmartDashboard::PutNumber("DT_Output_L1", outputL1);
			frc::SmartDashboard::PutNumber("DT_Current_L1", currentL1);
			frc::SmartDashboard::PutNumber("DT_Output_L2", outputL2);
			frc::SmartDashboard::PutNumber("DT_Current_L2", currentL2);

			frc::SmartDashboard::PutNumber("DT_Output_R3", outputR3);
			frc::SmartDashboard::PutNumber("DT_Current_R3", currentR3);
			frc::SmartDashboard::PutNumber("DT_Output_R4", outputR4);
			frc::SmartDashboard::PutNumber("DT_Current_R4", currentR4);
		}
	}
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drivetrain::Initialize(void) {
	std::printf("2135: DT Initialize\n");

	// When disabled, low gear and coast mode to allow easier pushing
	m_lowGear = true;
	m_brakeMode = false;
	m_throttleZeroed = false;
	// If ENABLED and AUTON mode, set brake mode
	if (!frc::RobotState::IsDisabled()) {
		if (!frc::RobotState::IsOperatorControl()) {
			m_brakeMode = true;
		}
	}

	MoveShiftGears(m_lowGear);
    MoveSetBrakeMode(m_brakeMode);
}

void Drivetrain::FaultDump(void) {

	//	Dump all Talon faults
	frc2135::TalonSRXUtils::TalonSRXFaultDump("DT L1", motorL1);
	frc2135::TalonSRXUtils::TalonSRXFaultDump("DT L2", motorL2);
	frc2135::TalonSRXUtils::TalonSRXFaultDump("DT R3", motorR3);
	frc2135::TalonSRXUtils::TalonSRXFaultDump("DT R4", motorR4);
	PigeonIMUFaultDump();

	// Dump Pigeon faults
	//frc2135::TalonSRXUtils::PigeonIMUFaultDump("DT IMU", gyro);
}

//	Joystick movement during Teleop

void Drivetrain::MoveWithJoysticks(std::shared_ptr<frc::Joystick> throttleJstick) {
	double xValue = 0.0;
	double yValue = 0.0;

	xValue = throttleJstick->GetX();
	yValue = throttleJstick->GetZ();

    xValue *= m_driveXScaling;
	if (!m_lowGear) {
		yValue *= m_driveYScaling;
	}

	if (m_talonValidL1 || m_talonValidR3) {
		// If joystick reports a very small throttle value
		if (fabs(yValue) < 0.05)
			m_throttleZeroed = true;

		// If throttle not zeroed, prevent joystick inputs from entering drive
		if (!m_throttleZeroed) {
			xValue = 0.0;
			yValue = 0.0;
		}
	}

//	diffDrive->ArcadeDrive(-yValue, xValue, true);
	diffDrive->ArcadeDrive(-yValue, 0.0, true);
}

void Drivetrain::ToggleDriveMode() {

	if (++m_curDriveMode >= DRIVEMODE_LAST)
		m_curDriveMode = DRIVEMODE_FIRST;

	std::printf("2135 Current Drive: %d\n", m_curDriveMode);
	frc::SmartDashboard::PutNumber("DriveMode", m_curDriveMode);

    switch (m_curDriveMode) {
    case DRIVEMODE_ARCADE_1_3:
		diffDrive.reset(new frc::DifferentialDrive(*motorL1, *motorR3));
        break;
    case DRIVEMODE_ARCADE_2_4:
		diffDrive.reset(new frc::DifferentialDrive(*motorL2, *motorR4));
        break;
    case DRIVEMODE_ARCADE_1_4:
		diffDrive.reset(new frc::DifferentialDrive(*motorL1, *motorR4));
        break;
    case DRIVEMODE_ARCADE_2_3:
		diffDrive.reset(new frc::DifferentialDrive(*motorL2, *motorR3));
        break;
    default:
        break;
    }
}

void Drivetrain::SetDriveMode(int driveMode)
{
	m_curDriveMode = driveMode;

	std::printf("2135 Current Drive: %d\n", m_curDriveMode);
	frc::SmartDashboard::PutNumber("DriveMode", m_curDriveMode);

    switch (m_curDriveMode) {
    case DRIVEMODE_ARCADE_1_3:
		diffDrive.reset(new frc::DifferentialDrive(*motorL1, *motorR3));
        break;
    case DRIVEMODE_ARCADE_2_4:
		diffDrive.reset(new frc::DifferentialDrive(*motorL2, *motorR4));
        break;
    case DRIVEMODE_ARCADE_1_4:
		diffDrive.reset(new frc::DifferentialDrive(*motorL1, *motorR4));
        break;
    case DRIVEMODE_ARCADE_2_3:
		diffDrive.reset(new frc::DifferentialDrive(*motorL2, *motorR3));
        break;
    default:
        break;
    }
}


//	Shift transmission gears

void Drivetrain::MoveShiftGears(bool lowGear) {
    m_lowGear = lowGear;

    std::printf("2135: DT %s Gear\n", (lowGear) ? "LOW" : "HIGH");
    frc::SmartDashboard::PutBoolean("DT Low Gear", lowGear);

    shifter->Set( (lowGear) ? shifter->kForward : shifter->kReverse);
}

//	Set Talon brake mode

void Drivetrain::MoveSetBrakeMode(bool brakeMode) {
	m_brakeMode = brakeMode;

	std::printf("2135: DT %s Mode\n", (brakeMode) ? "BRAKE" : "COAST");
	frc::SmartDashboard::PutBoolean("DT Brake Mode", brakeMode);

	NeutralMode brakeOutput;
	brakeOutput = (brakeMode) ? NeutralMode::Brake : NeutralMode::Coast;
	if (m_talonValidL1)
		motorL1->SetNeutralMode(brakeOutput);
	if (m_talonValidL2)
		motorL2->SetNeutralMode(brakeOutput);
	if (m_talonValidR3)
		motorR3->SetNeutralMode(brakeOutput);
	if (m_talonValidR4)
		motorR4->SetNeutralMode(brakeOutput);
}

double Drivetrain::GetEncoderPosition(int motorID) {
	int		ret = 0;

	switch (motorID) {
		case 1:			// Left Master
			if (m_talonValidL1)
				ret = motorL1->GetSelectedSensorPosition(m_pidIndex);
			break;
		case 3:			// Right Master
			if (m_talonValidR3)
				ret = motorR3->GetSelectedSensorPosition(m_pidIndex);
			break;
		default:
			break;
	}

	return ret;
}

///////////////////////////////////////////////////////////////////////////////

//	Pigeon IMU

bool Drivetrain::PigeonIMUInitialize() {
	int			i;
	int			retries = 5;
	int			deviceID = 0;
	int			pigeonVersion = 0;
	bool 		pigeonValid = false;
	ErrorCode 	error = OKAY;
	char		subsystem[] = "DT";
	char		name[] = "Pigeon IMU";

	std::printf("2135: TalonSRX Subsystem %s Name %s\n", subsystem, name);

    // Display Pigeon IMU firmware versions
	deviceID = pigeonIMU->GetDeviceNumber();
	if ((error = pigeonIMU->GetLastError()) != OKAY) {
		std::printf("2135: ERROR: %s %s GetDeviceNumber error - %d\n",
			subsystem, name, error);
		return error;
	}

	for (i = 0; i < retries; i++) {
		pigeonVersion = pigeonIMU->GetFirmwareVersion();
		if ((error = pigeonIMU->GetLastError()) != OKAY) {
			std::printf("2135: ERROR: %s %s ID %d GetFirmwareVersion error - %d\n",
				subsystem, name, deviceID, error);
			return error;
		}
		if (pigeonVersion == m_reqPigeonVer) {
			pigeonValid = true;
			break;
		}
		else {
			std::printf("2135: WARNING: %s %s ID %d Incorrect FW version %d.%d expected %d.%d\n",
				subsystem, name, deviceID, pigeonVersion/256, pigeonVersion%256, m_reqPigeonVer/256, m_reqPigeonVer%256);
		}
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

	if (pigeonValid) {
		// Initialize Pigeon IMU to all factory defaults
		if ((error = pigeonIMU->ConfigFactoryDefault(m_timeout)) != OKAY) {
			std::printf("2135: ERROR: %s %s ID %d ConfigFactoryDefault error - %d\n",
				subsystem, name, deviceID, error);
			pigeonValid = false;
		}

		double	heading = pigeonIMU->GetFusedHeading();
		bool angleIsGood = (pigeonIMU->GetState() == PigeonIMU::Ready) ? true : false;
		std::printf("2135: %s %s ID %d fused heading %5.1f angle is %s\n",
				subsystem, name, deviceID, heading, (angleIsGood) ? "TRUE" : "FALSE");

		pigeonIMU->SetYaw(0.0, m_timeout);
		if ((error = pigeonIMU->GetLastError()) != OKAY) {
			std::printf("2135: ERROR: %s %s ID %d SetFusedHeading error - %d\n",
				subsystem, name, deviceID, error);
			pigeonValid = false;
		}

		pigeonIMU->SetFusedHeading(0.0, m_timeout);
		if ((error = pigeonIMU->GetLastError()) != OKAY) {
			std::printf("2135: ERROR: %s %s ID %d SetYaw error - %d\n",
				subsystem, name, deviceID, error);
			pigeonValid = false;
		}

		std::printf("2135: %s %s ID %d ver %d.%d is RESPONSIVE and INITIALIZED (error %d)\n",
				subsystem, name, deviceID, pigeonVersion/256, pigeonVersion&0xff, error);
   	}
   	else {
		std::printf("2135: ERROR: %s %s ID %d ver %d.%d is UNRESPONSIVE, (error %d)\n",
			subsystem, name, deviceID, pigeonVersion/256, pigeonVersion&0xff, error);
   	   	pigeonValid = false;
   	}

	return pigeonValid;
}

void Drivetrain::PigeonIMUFaultDump(void) {
	PigeonIMU_Faults		faults;
	PigeonIMU_StickyFaults	stickyFaults;

	pigeonIMU->GetFaults(faults);
	if (faults.HasAnyFault())
		std::printf("2135: ERROR: %s %s ID %d has a FAULT - %d\n",
			"DT", "PigeonIMU", 2, faults.ToBitfield());

	pigeonIMU->GetStickyFaults(stickyFaults);
	pigeonIMU->ClearStickyFaults(m_timeout);
}

double Drivetrain::GetIMUHeading() {
	// Fused Heading is better than Yaw from Pigeon
	double	heading = 0.0;

	return heading;

	if (m_pigeonValid) {
		if (pigeonIMU->GetState() != PigeonIMU::Ready)
			std::printf("2135: ERROR: %s %s ID %d is NOT READY\n",
				"DT", "PigeonIMU", 2);
		heading = pigeonIMU->GetFusedHeading();
	}

    return heading;
}

void Drivetrain::ResetSensors(void) {
	if (m_talonValidL1)
		motorL1->SetSelectedSensorPosition(0, m_pidIndex, 0);
	if (m_talonValidR3)
		motorR3->SetSelectedSensorPosition(0, m_pidIndex, 0);
	if (m_pigeonValid) {
		pigeonIMU->SetYaw(0.0);
		pigeonIMU->SetFusedHeading(0.0, 0);
	}
}
