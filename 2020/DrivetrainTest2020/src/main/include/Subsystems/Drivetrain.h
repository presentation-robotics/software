// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#pragma once

#include <frc/Joystick.h>

#include "frc/commands/Subsystem.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "ctre/Phoenix.h"
#include "frc/DoubleSolenoid.h"
#include "frc/drive/DifferentialDrive.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

/**
 *
 *
 * @author ExampleAuthor
 */
class Drivetrain: public frc::Subsystem
{
private:
	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<WPI_TalonSRX> motorL1;
	std::shared_ptr<WPI_TalonSRX> motorR3;
	std::shared_ptr<frc::DifferentialDrive> diffDrive;
	std::shared_ptr<WPI_TalonSRX> motorL2;
	std::shared_ptr<WPI_TalonSRX> motorR4;
	std::shared_ptr<frc::DoubleSolenoid> shifter;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	std::shared_ptr<PigeonIMU> pigeonIMU;

	//	Declare constants
	int m_driveDebug = 2;						   // Debug flag to disable extra logging calls
	const int m_pidIndex = 0;					   // PID slot index for sensors
	const int m_timeout = 30;					   // CAN timeout in msec to wait for response
	const double COUNTS_PER_ROTATION = (1024 * 4); // CPR is 1024 and multiplied by 4
	const double WHEEL_DIA_INCHES = 6.0;
	const double CountsPerInch = COUNTS_PER_ROTATION / (WHEEL_DIA_INCHES * M_PI);
	const double m_circumInches = (WHEEL_DIA_INCHES * M_PI);
	const int m_reqPigeonVer = ((4 * 256) + 13); 	// Pigeon IMU version is 4.13

	//Declare module variables
	bool m_talonValidL1; 		// Health indicator for drive Talon Left 1
	bool m_talonValidL2; 		// Health indicator for drive Talon Left 2
	bool m_talonValidR3; 		// Health indicator for drive Talon Right 3
	bool m_talonValidR4; 		// Health indicator for drive Talon Right 4
	bool m_pigeonValid;  		// Health indicator for Pigeon IMU

	double m_driveXScaling; 	// Scaling applied to Joystick
	double m_driveYScaling; 	// Scaling applied to Joystick

	bool m_lowGear;   			// Low Gear or High Gear
	bool m_brakeMode; 			// Brake or Coast Mode for Talons
	bool m_isMovingAuto;	  	// Indicates an auton movement is active
	double m_turnAngle = 0.0; 	// Desired turn angle from present course

	bool m_throttleZeroed; 		// Throttle joystick zeroed check for safety
	int m_curDriveMode; 		// Current driving mode, arcade by default

public:
	Drivetrain();
	void InitDefaultCommand() override;
	void Periodic() override;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	typedef enum driveMode_e
	{ // Driving Algorithms
		DRIVEMODE_FIRST			= 0,
		DRIVEMODE_ARCADE_1_3 	= DRIVEMODE_FIRST,
		DRIVEMODE_ARCADE_2_4 	= 1,
		DRIVEMODE_ARCADE_1_4 	= 2,
		DRIVEMODE_ARCADE_2_3 	= 3,
		DRIVEMODE_LAST
	}
	driveMode_e;

	void Initialize(void);
	void FaultDump(void);

	void MoveWithJoysticks(std::shared_ptr<frc::Joystick> joystick);
	void ToggleDriveMode();
	void SetDriveMode(int driveMode);

	// Shifting Gears
	void MoveShiftGears(bool lowGear);
	// Brake or Coast Mode
	void MoveSetBrakeMode(bool m_brakeMode);

	double GetEncoderPosition(int motorID);

	bool PigeonIMUInitialize();
	void PigeonIMUFaultDump(void);
	double GetIMUHeading();

	void ResetSensors();
};
